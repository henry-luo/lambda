// dvi_parser.hpp - DVI File Parser for Testing
//
// Parses DVI (DeVice Independent) files generated by TeX to extract
// glyph positions for comparison with Lambda's typesetting output.
//
// DVI Format Reference: https://ctan.org/pkg/dvitype
// Also see: TeXBook Appendix A

#ifndef TEX_DVI_PARSER_HPP
#define TEX_DVI_PARSER_HPP

#include "lib/arena.h"
#include "lib/arraylist.h"
#include <cstdint>
#include <cstdio>

namespace tex {
namespace dvi {

// ============================================================================
// DVI Opcodes
// ============================================================================

enum DVIOpcode : uint8_t {
    // set_char_0 to set_char_127: 0-127 (set character and advance)
    DVI_SET_CHAR_0   = 0,
    DVI_SET_CHAR_127 = 127,

    // set1 to set4: 128-131 (set character, 1-4 byte argument)
    DVI_SET1 = 128,
    DVI_SET2 = 129,
    DVI_SET3 = 130,
    DVI_SET4 = 131,

    // set_rule: 132 (set rule and advance)
    DVI_SET_RULE = 132,

    // put1 to put4: 133-136 (put character without advance)
    DVI_PUT1 = 133,
    DVI_PUT2 = 134,
    DVI_PUT3 = 135,
    DVI_PUT4 = 136,

    // put_rule: 137 (put rule without advance)
    DVI_PUT_RULE = 137,

    // nop: 138 (no operation)
    DVI_NOP = 138,

    // bop: 139 (beginning of page)
    DVI_BOP = 139,

    // eop: 140 (end of page)
    DVI_EOP = 140,

    // push: 141 (push current state)
    DVI_PUSH = 141,

    // pop: 142 (pop state)
    DVI_POP = 142,

    // right1 to right4: 143-146 (move right)
    DVI_RIGHT1 = 143,
    DVI_RIGHT2 = 144,
    DVI_RIGHT3 = 145,
    DVI_RIGHT4 = 146,

    // w0 to w4: 147-151 (move right by w, optionally set w)
    DVI_W0 = 147,
    DVI_W1 = 148,
    DVI_W2 = 149,
    DVI_W3 = 150,
    DVI_W4 = 151,

    // x0 to x4: 152-156 (move right by x, optionally set x)
    DVI_X0 = 152,
    DVI_X1 = 153,
    DVI_X2 = 154,
    DVI_X3 = 155,
    DVI_X4 = 156,

    // down1 to down4: 157-160 (move down)
    DVI_DOWN1 = 157,
    DVI_DOWN2 = 158,
    DVI_DOWN3 = 159,
    DVI_DOWN4 = 160,

    // y0 to y4: 161-165 (move down by y, optionally set y)
    DVI_Y0 = 161,
    DVI_Y1 = 162,
    DVI_Y2 = 163,
    DVI_Y3 = 164,
    DVI_Y4 = 165,

    // z0 to z4: 166-170 (move down by z, optionally set z)
    DVI_Z0 = 166,
    DVI_Z1 = 167,
    DVI_Z2 = 168,
    DVI_Z3 = 169,
    DVI_Z4 = 170,

    // fnt_num_0 to fnt_num_63: 171-234 (select font)
    DVI_FNT_NUM_0  = 171,
    DVI_FNT_NUM_63 = 234,

    // fnt1 to fnt4: 235-238 (select font, 1-4 byte argument)
    DVI_FNT1 = 235,
    DVI_FNT2 = 236,
    DVI_FNT3 = 237,
    DVI_FNT4 = 238,

    // xxx1 to xxx4: 239-242 (special string)
    DVI_XXX1 = 239,
    DVI_XXX2 = 240,
    DVI_XXX3 = 241,
    DVI_XXX4 = 242,

    // fnt_def1 to fnt_def4: 243-246 (define font)
    DVI_FNT_DEF1 = 243,
    DVI_FNT_DEF2 = 244,
    DVI_FNT_DEF3 = 245,
    DVI_FNT_DEF4 = 246,

    // pre: 247 (preamble)
    DVI_PRE = 247,

    // post: 248 (postamble)
    DVI_POST = 248,

    // post_post: 249 (end of postamble)
    DVI_POST_POST = 249,

    // 250-255: undefined (should not appear in valid DVI)
};

// ============================================================================
// DVI Data Structures
// ============================================================================

// Font definition from DVI file
struct DVIFont {
    uint32_t font_num;        // Font number used in DVI
    uint32_t checksum;        // TFM checksum
    uint32_t scale;           // Scale factor (scaled points)
    uint32_t design_size;     // Design size (scaled points)
    char* area;               // Directory (may be empty)
    char* name;               // Font name (e.g., "cmr10")
};

// Positioned glyph extracted from DVI
struct PositionedGlyph {
    int32_t codepoint;        // Character code
    int32_t h;                // Horizontal position (scaled points)
    int32_t v;                // Vertical position (scaled points)
    uint32_t font_num;        // Font number
};

// Rule (filled rectangle) from DVI
struct PositionedRule {
    int32_t h;                // Horizontal position
    int32_t v;                // Vertical position
    int32_t width;            // Rule width (scaled points)
    int32_t height;           // Rule height (scaled points)
};

// Page extracted from DVI
struct DVIPage {
    int32_t count[10];        // Page counters (c0-c9)
    int32_t prev_bop;         // Pointer to previous BOP

    // Content
    PositionedGlyph* glyphs;
    int glyph_count;
    int glyph_capacity;

    PositionedRule* rules;
    int rule_count;
    int rule_capacity;
};

// DVI file preamble
struct DVIPreamble {
    uint8_t id;               // DVI format ID (should be 2)
    uint32_t num;             // Numerator of units
    uint32_t den;             // Denominator of units
    uint32_t mag;             // Magnification (1000 = 1x)
    char* comment;            // Comment string
};

// ============================================================================
// DVI Parser Class
// ============================================================================

class DVIParser {
public:
    DVIParser(Arena* arena);
    ~DVIParser();

    // Parse a DVI file from memory
    bool parse(const uint8_t* data, size_t size);

    // Parse a DVI file from disk
    bool parse_file(const char* filename);

    // Get preamble info
    const DVIPreamble* preamble() const { return &preamble_; }

    // Get number of pages
    int page_count() const { return page_count_; }

    // Get a specific page (0-indexed)
    const DVIPage* page(int index) const;

    // Get font by number
    const DVIFont* font(uint32_t font_num) const;

    // Get all fonts
    const DVIFont* fonts() const { return fonts_; }
    int font_count() const { return font_count_; }

    // Unit conversion: DVI scaled points to points
    // 1 pt = 65536 sp (scaled points)
    static float sp_to_pt(int32_t sp) {
        return sp / 65536.0f;
    }

    // Unit conversion: DVI scaled points to pixels (at 72.27 dpi)
    static float sp_to_px(int32_t sp) {
        return sp / 65536.0f * (96.0f / 72.27f);
    }

    // Error message (if parse failed)
    const char* error() const { return error_; }

private:
    Arena* arena_;

    // Parsing state
    const uint8_t* data_;
    size_t size_;
    size_t pos_;

    // Parsed content
    DVIPreamble preamble_;
    DVIFont* fonts_;
    int font_count_;
    int font_capacity_;

    DVIPage* pages_;
    int page_count_;
    int page_capacity_;

    char* error_;

    // DVI state during page processing
    struct State {
        int32_t h, v;         // Current position
        int32_t w, x, y, z;   // Spacing registers
        uint32_t f;           // Current font
    };
    State state_;
    State* state_stack_;
    int stack_depth_;
    int stack_capacity_;

    // Reading helpers
    uint8_t read_u8();
    int8_t read_i8();
    uint16_t read_u16();
    int16_t read_i16();
    uint32_t read_u24();
    int32_t read_i24();
    uint32_t read_u32();
    int32_t read_i32();
    char* read_string(int len);

    // Parsing phases
    bool parse_preamble();
    bool parse_postamble();
    bool parse_pages();
    bool process_page(DVIPage* page);

    // Page content helpers
    void add_glyph(DVIPage* page, int32_t codepoint);
    void add_rule(DVIPage* page, int32_t width, int32_t height);
    void push_state();
    void pop_state();

    // Error handling
    void set_error(const char* msg);
};

// ============================================================================
// DVI Text Output (for debugging)
// ============================================================================

// Dump DVI contents in human-readable format (similar to dvitype)
void dump_dvi(const DVIParser& parser, FILE* out);

// Dump a single page
void dump_dvi_page(const DVIPage* page, const DVIParser& parser, FILE* out);

} // namespace dvi
} // namespace tex

#endif // TEX_DVI_PARSER_HPP
