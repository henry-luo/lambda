#!/usr/bin/env python3
"""
Generate complete HTML5 named entity table from WHATWG spec.
Downloads entities.json and generates C code for html5_tokenizer.cpp

Usage: python3 generate_html5_entities.py > html5_entities.inc
"""

import json
import urllib.request
import sys

def codepoint_to_utf8(cp):
    """Convert Unicode codepoint to UTF-8 bytes."""
    return chr(cp).encode('utf-8')

def codepoints_to_utf8_string(codepoints):
    """Convert list of codepoints to UTF-8 string."""
    return ''.join(chr(cp) for cp in codepoints).encode('utf-8')

def escape_c_string(utf8_bytes):
    """Escape UTF-8 bytes for C string literal."""
    result = []
    for b in utf8_bytes:
        if 0x20 <= b <= 0x7E and b not in (ord('"'), ord('\\')):
            result.append(chr(b))
        else:
            result.append(f'\\x{b:02X}')
    return ''.join(result)

def main():
    # Fetch WHATWG entity list
    url = "https://html.spec.whatwg.org/entities.json"
    try:
        with urllib.request.urlopen(url) as response:
            entities = json.loads(response.read().decode('utf-8'))
    except Exception as e:
        print(f"// Error fetching entities: {e}", file=sys.stderr)
        sys.exit(1)

    # Process entities - we need both semicolon and non-semicolon versions
    # The spec has both "&amp" and "&amp;" - we handle this
    processed = {}

    for name, data in entities.items():
        # Remove leading & from name
        if not name.startswith('&'):
            continue

        entity_name = name[1:]  # Remove &
        has_semicolon = entity_name.endswith(';')

        # We want the version WITHOUT semicolon for storage
        # (lookup code handles both forms)
        clean_name = entity_name.rstrip(';')

        codepoints = data.get('codepoints', [])
        if not codepoints:
            continue

        try:
            utf8_bytes = codepoints_to_utf8_string(codepoints)
            utf8_escaped = escape_c_string(utf8_bytes)
        except Exception as e:
            print(f"// Error processing {name}: {e}", file=sys.stderr)
            continue

        # Store the entry - prefer semicolon version for the data
        # but use clean name (no semicolon) for lookup
        # Only store entries with semicolon to avoid duplicates
        if has_semicolon:
            processed[clean_name] = utf8_escaped

    # Also ensure legacy entities without semicolons are included
    # These are entities that work without semicolon in HTML5
    legacy_no_semi = ["amp", "lt", "gt", "quot", "AMP", "LT", "GT", "QUOT", "REG", "COPY"]
    for name in legacy_no_semi:
        if name not in processed:
            # Find the semicolon version
            for key in entities:
                if key == f"&{name};":
                    codepoints = entities[key].get('codepoints', [])
                    if codepoints:
                        utf8_bytes = codepoints_to_utf8_string(codepoints)
                        processed[name] = escape_c_string(utf8_bytes)
                    break

    # Sort by name for binary search capability
    sorted_names = sorted(processed.keys())

    # Generate output
    print("// Auto-generated HTML5 named entity table from WHATWG spec")
    print("// Source: https://html.spec.whatwg.org/entities.json")
    print(f"// Total entities: {len(sorted_names)}")
    print("// Generated by utils/generate_html5_entities.py")
    print("")
    print("static const NamedEntity named_entities[] = {")

    for name in sorted_names:
        replacement = processed[name]
        # Escape any quotes in the name (shouldn't be any, but be safe)
        safe_name = name.replace('\\', '\\\\').replace('"', '\\"')
        print(f'    {{"{safe_name}", "{replacement}"}},')

    print("    {nullptr, nullptr}")
    print("};")
    print("")
    print(f"// Entity count: {len(sorted_names)}")

if __name__ == "__main__":
    main()
