#!/bin/bash
# generate_latexml_refs.sh - Generate HTML reference files from LaTeXML fixtures
#
# This script processes all .tex files in test/latexml/fixtures (excluding math/)
# and generates HTML reference files using the latexml tool.
# Output files use *.latexml.html suffix to distinguish from other expected outputs.
#
# Usage:
#   ./utils/generate_latexml_refs.sh [--clean] [--verbose] [--test=<name>]
#
# Options:
#   --clean    Remove existing reference files before generating
#   --verbose  Show detailed output
#   --test=X   Only process files matching pattern X
#
# Requirements:
#   - LaTeXML must be installed. Install via:
#     brew install latexml   (macOS)
#     cpanm LaTeXML          (Perl)
#     apt-get install latexml (Debian/Ubuntu)

set -e

SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"
PROJECT_ROOT="$(dirname "$SCRIPT_DIR")"
FIXTURES_DIR="$PROJECT_ROOT/test/latexml/fixtures"
OUTPUT_DIR="$PROJECT_ROOT/test/latexml/expected"

# Find latexmlc - check system first, then local
LATEXMLC=""
if command -v latexmlc &> /dev/null; then
    LATEXMLC="latexmlc"
elif [ -x "$PROJECT_ROOT/latexml/bin/latexmlc" ]; then
    # Try local installation with PERL5LIB
    export PERL5LIB="$PROJECT_ROOT/latexml/lib:$PERL5LIB"
    LATEXMLC="$PROJECT_ROOT/latexml/bin/latexmlc"
fi

# Check if latexml is available
if [ -z "$LATEXMLC" ]; then
    echo "Error: latexmlc not found."
    echo ""
    echo "Please install LaTeXML using one of these methods:"
    echo "  macOS:         brew install latexml"
    echo "  Perl (cpanm):  cpanm LaTeXML"
    echo "  Debian/Ubuntu: apt-get install latexml"
    echo ""
    exit 1
fi

# Test if latexmlc works (use --help since --VERSION returns exit code 1)
if ! "$LATEXMLC" --help &> /dev/null; then
    echo "Error: latexmlc found but not working properly."
    echo "Path: $LATEXMLC"
    echo ""
    echo "Try installing via: brew install latexml"
    exit 1
fi

# Parse arguments
CLEAN=0
VERBOSE=0
TEST_PATTERN=""

for arg in "$@"; do
    case $arg in
        --clean)
            CLEAN=1
            ;;
        --verbose)
            VERBOSE=1
            ;;
        --test=*)
            TEST_PATTERN="${arg#*=}"
            ;;
    esac
done

# Clean if requested
if [ "$CLEAN" -eq 1 ]; then
    echo "Cleaning existing reference files..."
    rm -rf "$OUTPUT_DIR"
fi

# Create output directory structure
mkdir -p "$OUTPUT_DIR"

# Counters
TOTAL=0
SUCCESS=0
FAILED=0
SKIPPED=0

# Get list of tex files (excluding math/)
TEX_FILES=$(find "$FIXTURES_DIR" -name "*.tex" ! -path "*/math/*" | sort)

echo "LaTeXML HTML Reference Generator"
echo "================================"
echo "Tool:     $LATEXMLC"
echo "Fixtures: $FIXTURES_DIR"
echo "Output:   $OUTPUT_DIR"
echo ""

for tex_file in $TEX_FILES; do
    # Get relative path from fixtures dir
    rel_path="${tex_file#$FIXTURES_DIR/}"
    
    # Check test pattern
    if [ -n "$TEST_PATTERN" ] && [[ ! "$rel_path" == *"$TEST_PATTERN"* ]]; then
        continue
    fi
    
    # Create output path (same structure, .latexml.html extension)
    dir_name=$(dirname "$rel_path")
    base_name=$(basename "$rel_path" .tex)
    out_dir="$OUTPUT_DIR/$dir_name"
    out_file="$out_dir/$base_name.latexml.html"
    
    mkdir -p "$out_dir"
    
    TOTAL=$((TOTAL + 1))
    
    # Skip if output exists and is newer than input (unless --clean)
    if [ -f "$out_file" ] && [ "$out_file" -nt "$tex_file" ]; then
        if [ "$VERBOSE" -eq 1 ]; then
            echo "[SKIP] $rel_path (up to date)"
        fi
        SKIPPED=$((SKIPPED + 1))
        continue
    fi
    
    if [ "$VERBOSE" -eq 1 ]; then
        echo "[PROC] $rel_path"
    else
        printf "."
    fi
    
    # Run latexmlc to convert tex -> html
    # Options:
    #   --format=html5  : Generate HTML5 output
    #   --nocomments    : Don't include XML comments
    #   --pmml          : Use presentation MathML
    #   --dest=...      : Output file
    if "$LATEXMLC" \
        --format=html5 \
        --nocomments \
        --pmml \
        --dest="$out_file" \
        "$tex_file" 2>/dev/null; then
        SUCCESS=$((SUCCESS + 1))
        
        # Post-process: normalize the HTML for comparison
        # Remove timestamps, random IDs, etc.
        if [ -f "$out_file" ]; then
            # Create temp file
            temp_file=$(mktemp)
            
            # Normalize: remove LaTeXML version comments, normalize whitespace
            sed -E \
                -e 's/<!-- Generated by LaTeXML .* -->//g' \
                -e 's/id="[a-zA-Z0-9._-]*"//g' \
                -e 's/about="[^"]*"//g' \
                -e 's/resource="[^"]*"//g' \
                -e 's/xml:id="[^"]*"//g' \
                "$out_file" > "$temp_file"
            
            mv "$temp_file" "$out_file"
        fi
    else
        FAILED=$((FAILED + 1))
        if [ "$VERBOSE" -eq 1 ]; then
            echo "  ERROR: Failed to process $rel_path"
        fi
        # Create a marker file for failed conversions
        echo "LATEXML_CONVERSION_FAILED" > "$out_file.error"
    fi
done

echo ""
echo ""
echo "Summary"
echo "-------"
echo "Total:   $TOTAL"
echo "Success: $SUCCESS"
echo "Skipped: $SKIPPED"
echo "Failed:  $FAILED"

# List failed files if any
if [ "$FAILED" -gt 0 ]; then
    echo ""
    echo "Failed files:"
    find "$OUTPUT_DIR" -name "*.error" | while read error_file; do
        echo "  ${error_file%.error}"
    done
fi

exit 0
