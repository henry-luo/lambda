// generate_premake_v2.ls - Lambda Script Premake5 Generator
// Usage: ./lambda.exe run utils/generate_premake_v2.ls
// Generates Premake5 Lua build file from build_lambda_config.json
//
// Architecture: All array/data computation happens procedurally in pn functions
// to work around comprehension-based array building memory issues.
// fn functions do string formatting only.
//
// Source enumeration: Uses input(dir, "dir") to enumerate source files directly.

// ============================================================
// === Core String Utilities ===
// ============================================================

fn q(s) { "\""; s; "\"" }

fn ind(n) {
    if (n <= 0) ""
    else if (n == 1) "    "
    else if (n == 2) "        "
    else if (n == 3) "            "
    else "                "
}

fn strip_exe(name) {
    if (ends_with(name, ".exe")) slice(name, 0, len(name) - 4) else name
}

fn detect_platform() {
    let p = sys.os.platform;
    if (p == "darwin") "macos" else if (p == "linux") "linux" else "windows"
}

// ============================================================
// === Library Lookup (pure fn - no array building) ===
// ============================================================

fn find_in_libs(libs, name) {
    let found = [for (lib in libs where lib.name == name) lib];
    if (len(found) > 0) found[0] else null
}

fn find_target(targets, name) {
    let found = [for (t in targets where t.name == name) t];
    if (len(found) > 0) found[0] else null
}

// ============================================================
// === Lua Block Generators (fn - string building only) ===
// ============================================================

// multi-line block with trailing comma on each item
fn lua_block(name, items, depth) {
    let formatted = [for (item in items) ind(depth + 1) ++ q(item) ++ ","];
    ind(depth); name; " {\n"; str_join(formatted, "\n"); "\n"; ind(depth); "}\n"
}

// multi-line defines block with trailing comma
fn gen_defines_block(defs, depth) {
    if (len(defs) == 0) ""
    else ind(depth) ++ "defines {\n" ++ str_join([for (d in defs) ind(depth + 1) ++ q(d) ++ ","], "\n") ++ "\n" ++ ind(depth) ++ "}\n"
}

fn gen_files_block(files, depth) {
    if (len(files) == 0) "" else lua_block("files", files, depth)
}

fn gen_includes_block(includes, depth) {
    if (len(includes) == 0) "" else lua_block("includedirs", includes, depth)
}

fn gen_links_block(links, depth) {
    if (len(links) == 0) ""
    else lua_block("links", links, depth)
}

fn gen_empty_links_block(depth) {
    ind(depth); "links {\n"; ind(depth); "}\n"
}

fn gen_buildopts_block(opts, depth) {
    if (len(opts) == 0) "" else lua_block("buildoptions", opts, depth)
}

fn gen_linkopts_block(paths, depth) {
    if (len(paths) == 0) "" else lua_block("linkoptions", paths, depth)
}

fn gen_empty_linkopts_block(depth) {
    ind(depth); "linkoptions {\n"; ind(depth); "}\n"
}

fn gen_libdirs_block(dirs, depth) {
    if (len(dirs) == 0) "" else lua_block("libdirs", dirs, depth)
}

fn gen_removefiles_block(patterns, depth) {
    if (len(patterns) == 0) "" else lua_block("removefiles", patterns, depth)
}

// ============================================================
// === Section Generators ===
// ============================================================

fn gen_header(platform) {
    let pname = if (platform == "macos") "macOS"
                else if (platform == "linux") "Linux" else "Windows";
    "-- Generated by utils/generate_premake.py for "; pname; "\n";
    "-- Lambda Build System Premake5 Configuration\n";
    "-- Platform: "; pname; "\n";
    "-- DO NOT EDIT MANUALLY - Regenerate using: python3 utils/generate_premake.py\n";
    "\n"
}

fn gen_workspace(c) {
    let out = c.output or "lambda.exe";
    let start = strip_exe(out);
    "workspace \"Lambda\"\n";
    ind(1); "configurations { \"Debug\", \"Release\" }\n";
    ind(1); "platforms { \"native\" }\n";
    ind(1); "location \"build/premake\"\n";
    ind(1); "startproject "; q(start); "\n";
    ind(1); "toolset \"gcc\"\n";
    ind(1); "\n";
    ind(1); "-- Global settings\n";
    ind(1); "cppdialect \"C++17\"\n";
    ind(1); "cdialect \"C99\"\n";
    ind(1); "warnings \"Extra\"\n";
    ind(1); "\n"
}

fn gen_debug_config() {
    ind(1); "filter \"configurations:Debug\"\n";
    ind(2); "defines { \"DEBUG\" }\n";
    ind(2); "symbols \"On\"\n";
    ind(2); "optimize \"Off\"\n";
    ind(1); "\n"
}

fn gen_release_config_macos() {
    ind(1); "filter \"configurations:Release\"\n";
    ind(2); "defines { \"NDEBUG\" }\n";
    ind(2); "symbols \"Off\"\n";
    ind(2); "optimize \"On\"\n";
    ind(2); "-- Dead code elimination and ThinLTO\n";
    ind(2); "buildoptions {\n";
    ind(3); "\"-flto=thin\",\n";
    ind(3); "\"-ffunction-sections\",\n";
    ind(3); "\"-fdata-sections\",\n";
    ind(3); "\"-fvisibility=hidden\",\n";
    ind(3); "\"-fvisibility-inlines-hidden\",\n";
    ind(2); "}\n";
    ind(2); "-- macOS: strip dead code and symbols with ThinLTO\n";
    ind(2); "linkoptions {\n";
    ind(3); "\"-flto=thin\",\n";
    ind(3); "\"-Wl,-dead_strip\",\n";
    ind(3); "\"-Wl,-x\",  -- Strip local symbols\n";
    ind(2); "}\n";
    ind(1); "\n"
}

fn gen_release_config_linux() {
    ind(1); "filter \"configurations:Release\"\n";
    ind(2); "defines { \"NDEBUG\" }\n";
    ind(2); "symbols \"Off\"\n";
    ind(2); "optimize \"On\"\n";
    ind(2); "buildoptions {\n";
    ind(3); "\"-flto=thin\",\n";
    ind(3); "\"-ffunction-sections\",\n";
    ind(3); "\"-fdata-sections\",\n";
    ind(2); "}\n";
    ind(2); "linkoptions {\n";
    ind(3); "\"-flto=thin\",\n";
    ind(3); "\"-Wl,--gc-sections\",\n";
    ind(2); "}\n";
    "\n"
}

fn gen_platform_globals() {
    ind(1); "-- Native Linux build settings\n";
    ind(1); "toolset \"gcc\"\n";
    ind(1); "defines { \"LINUX\", \"_GNU_SOURCE\", \"NATIVE_LINUX_BUILD\" }\n";
    ind(1); "\n"; ind(1); "\n";
    ind(1); "filter {}\n";
    "\n"
}

// === Project Header (no blank line between objdir and targetname) ===

fn gen_project_header(name, kind_str, lang, tdir) {
    "project "; q(name); "\n";
    ind(1); "kind "; q(kind_str); "\n";
    ind(1); "language "; q(lang); "\n";
    ind(1); "targetdir "; q(tdir); "\n";
    ind(1); "objdir \"build/obj/%{prj.name}\"\n"
}

// === Filter Blocks (for mixed C/C++ projects) ===

fn gen_filter_blocks() {
    ind(1); "filter \"files:**.c\"\n";
    ind(2); "buildoptions {\n";
    ind(3); "\"-pedantic\",\n";
    ind(3); "\"-fdiagnostics-color=auto\",\n";
    ind(3); "\"-fno-omit-frame-pointer\",\n";
    ind(3); "\"-std=c17\",\n";
    ind(2); "}\n";
    ind(1); "\n";
    ind(1); "filter \"files:**.cpp\"\n";
    ind(2); "buildoptions {\n";
    ind(3); "\"-pedantic\",\n";
    ind(3); "\"-fdiagnostics-color=auto\",\n";
    ind(3); "\"-fno-omit-frame-pointer\",\n";
    ind(3); "\"-std=c++17\",\n";
    ind(2); "}\n";
    ind(1); "\n";
    ind(1); "filter {}\n"
}

// === Frameworks ===

fn gen_frameworks_linkopts(depth) {
    ind(depth); "linkoptions {\n";
    ind(depth + 1); "\"-framework CoreFoundation\",\n";
    ind(depth + 1); "\"-framework CoreServices\",\n";
    ind(depth + 1); "\"-framework SystemConfiguration\",\n";
    ind(depth + 1); "\"-framework Cocoa\",\n";
    ind(depth + 1); "\"-framework IOKit\",\n";
    ind(depth + 1); "\"-framework CoreVideo\",\n";
    ind(depth + 1); "\"-framework OpenGL\",\n";
    ind(depth + 1); "\"-framework Foundation\",\n";
    ind(depth + 1); "\"-framework CoreGraphics\",\n";
    ind(depth + 1); "\"-framework AppKit\",\n";
    ind(depth + 1); "\"-framework Carbon\",\n";
    ind(depth); "}\n"
}

// ============================================================
// === lambda-lib Project ===
// ============================================================

fn gen_lambda_lib(t, lib_includes) {
    let sources = t.sources or [];
    let lib_names = t.libraries or [];
    let defines = t.defines or [];
    gen_project_header("lambda-lib", "StaticLib", "C", "build/lib");
    ind(1); "\n";
    ind(1); "-- Meta-library: combines source files from dependencies\n";
    gen_files_block(sources, 1);
    ind(1); "\n";
    gen_includes_block(lib_includes, 1);
    ind(1); "\n";
    gen_libdirs_block(["/opt/homebrew/lib", "/usr/local/lib"], 1);
    ind(1); "\n";
    gen_links_block(lib_names, 1);
    ind(1); "\n";
    gen_buildopts_block(["-pedantic", "-fdiagnostics-color=auto", "-fno-omit-frame-pointer"], 1);
    ind(1); "\n";
    gen_defines_block(defines, 1);
    ind(1); "\n";
    "\n"
}

// ============================================================
// === lambda-input-full-cpp Project ===
// ============================================================

fn gen_input_full(t, input_includes, static_paths, dyn_links, platform) {
    let source_files = t.source_files or [];
    let patterns = t.source_patterns or [];
    let excludes = t.exclude_patterns or [];
    let defines = t.defines or [];
    let link_type = t.link or "static";
    let kind_str = if (link_type == "dynamic") "SharedLib" else "StaticLib";
    gen_project_header("lambda-input-full-cpp", kind_str, "C++", "build/lib");
    ind(1); "\n";
    // files block - individual source files
    gen_files_block(source_files, 1);
    ind(1); "\n";
    // pattern files blocks - each pattern in its own files block
    str_join([for (p in patterns)
        ind(1) ++ "files {\n" ++ ind(2) ++ q(p) ++ ",\n" ++ ind(1) ++ "}\n" ++ ind(1)], "\n");
    "\n";
    // removefiles
    if (len(excludes) > 0) gen_removefiles_block(excludes, 1) ++ ind(1) ++ "\n" else "";
    // includes
    gen_includes_block(input_includes, 1);
    ind(1); "\n";
    // filter blocks for mixed C/C++
    gen_filter_blocks();
    ind(1); "\n";
    // libdirs
    gen_libdirs_block(["/opt/homebrew/lib", "/usr/local/lib", "build/lib"], 1);
    ind(1); "\n";
    // static linkoptions
    gen_linkopts_block(static_paths, 1);
    ind(1); "\n";
    // dynamic links
    gen_links_block(dyn_links, 1);
    ind(1); "\n";
    // defines
    gen_defines_block(defines, 1);
    ind(1); "\n";
    // frameworks (macOS)
    if (platform == "macos") ind(1) ++ "-- Add macOS frameworks\n" ++ gen_frameworks_linkopts(1) ++ ind(1) ++ "\n" else "";
    // c++ stdlib
    ind(1); "-- Automatically added C++ standard library\n";
    gen_links_block(["c++"], 1);
    ind(1); "\n";
    "\n"
}

// ============================================================
// === lambda-input-full Wrapper ===
// ============================================================

fn gen_input_wrapper() {
    gen_project_header("lambda-input-full", "SharedLib", "C++", "build/lib");
    ind(1); "\n";
    ind(1); "-- Wrapper library with empty source file\n";
    ind(1); "files {\n";
    ind(2); "\"utils/empty.cpp\",\n";
    ind(1); "}\n";
    ind(1); "\n";
    ind(1); "links {\n";
    ind(2); "\"lambda-input-full-cpp\",\n";
    ind(1); "}\n";
    ind(1); "\n";
    "\n"
}

// ============================================================
// === Main Executable ===
// ============================================================

fn gen_exe_links_macos() {
    ind(1); "-- Dynamic libraries\n";
    ind(1); "filter \"platforms:native\"\n";
    ind(2); "links {\n";
    ind(3); "\"re2\",\n";
    ind(2); "}\n";
    ind(1); "\n";
    gen_frameworks_linkopts(2);
    ind(1); "\n";
    ind(1); "filter {}\n";
    ind(1); "\n"
}

fn gen_lambda_exe(name, files, full_includes, static_paths, platform) {
    gen_project_header(name, "ConsoleApp", "C++", ".");
    ind(1); "targetname "; q(name); "\n";
    ind(1); "targetextension \".exe\"\n";
    ind(1); "\n";
    gen_files_block(files, 1);
    ind(1); "\n";
    gen_includes_block(full_includes, 1);
    ind(1); "\n";
    gen_libdirs_block(["/opt/homebrew/lib", "/usr/local/lib", "build/lib"], 1);
    ind(1); "\n";
    gen_linkopts_block(static_paths, 1);
    ind(1); "\n";
    // dynamic libraries (macOS)
    if (platform == "macos") gen_exe_links_macos() else "";
    gen_buildopts_block(["-pedantic", "-fdiagnostics-color=auto", "-fno-omit-frame-pointer"], 1);
    ind(1); "\n";
    ind(1); "-- C++ specific options\n";
    ind(1); "filter \"files:**.cpp\"\n";
    ind(2); "buildoptions { \"-std=c++17\" }\n";
    ind(1); "\n";
    ind(1); "-- C specific options\n";
    ind(1); "filter \"files:**.c\"\n";
    ind(2); "buildoptions { \"-std=c99\" }\n";
    ind(1); "\n";
    ind(1); "filter {}\n";
    ind(1); "\n";
    gen_defines_block(["_GNU_SOURCE"], 1);
    ind(1); "\n";
    "\n"
}

// ============================================================
// === Test Project - Simple (no lambda-input-full) ===
// ============================================================

fn gen_test_simple(proj_name, sources, full_includes, link_names, lib_paths, defs, all_opts) {
    gen_project_header(proj_name, "ConsoleApp", "C++", "test");
    ind(1); "targetname "; q(proj_name); "\n";
    ind(1); "targetextension \".exe\"\n";
    ind(1); "\n";
    gen_files_block(sources, 1);
    ind(1); "\n";
    gen_includes_block(full_includes, 1);
    ind(1); "\n";
    if (len(defs) > 0) gen_defines_block(defs, 1) ++ ind(1) ++ "\n" else "";
    gen_libdirs_block(["/opt/homebrew/lib", "/opt/homebrew/Cellar/criterion/2.4.2_2/lib", "/usr/local/lib", "build/lib"], 1);
    ind(1); "\n";
    if (len(link_names) > 0) gen_links_block(link_names, 1) else gen_empty_links_block(1);
    ind(1); "\n";
    gen_linkopts_block(lib_paths, 1);
    ind(1); "\n";
    // build options
    gen_buildopts_block(all_opts, 1);
    ind(1); "\n";
    // ASAN
    ind(1); "-- AddressSanitizer for test projects only\n";
    ind(1); "filter { \"configurations:Debug\", \"not platforms:Linux_x64\" }\n";
    ind(2); "buildoptions { \"-fsanitize=address\", \"-fno-omit-frame-pointer\" }\n";
    ind(2); "linkoptions { \"-fsanitize=address\" }\n";
    ind(1); "\n";
    ind(1); "filter {}\n";
    ind(1); "\n";
    "\n"
}

// ============================================================
// === Test Project - With lambda-input-full dependency ===
// ============================================================

fn gen_test_input_full(proj_name, sources, full_includes, link_names, lib_paths, defs, all_opts, platform) {
    gen_project_header(proj_name, "ConsoleApp", "C++", "test");
    ind(1); "targetname "; q(proj_name); "\n";
    ind(1); "targetextension \".exe\"\n";
    ind(1); "\n";
    gen_files_block(sources, 1);
    ind(1); "\n";
    gen_includes_block(full_includes, 1);
    ind(1); "\n";
    if (len(defs) > 0) gen_defines_block(defs, 1) ++ ind(1) ++ "\n" else "";
    gen_libdirs_block(["/opt/homebrew/lib", "/opt/homebrew/Cellar/criterion/2.4.2_2/lib", "/usr/local/lib", "build/lib"], 1);
    ind(1); "\n";
    gen_links_block(link_names, 1);
    ind(1); "\n";
    gen_linkopts_block(lib_paths, 1);
    ind(1); "\n";
    // empty linkoptions block
    gen_empty_linkopts_block(1);
    ind(1); "\n";
    // dynamic libraries
    ind(1); "-- Add dynamic libraries\n";
    gen_links_block(["re2", "ncurses"], 1);
    ind(1); "\n";
    // tree-sitter linkoptions (empty)
    ind(1); "-- Add tree-sitter libraries using linkoptions to append to LIBS section\n";
    gen_empty_linkopts_block(1);
    ind(1); "\n";
    // frameworks
    if (platform == "macos") ind(1) ++ "-- Add macOS frameworks\n" ++ gen_frameworks_linkopts(1) ++ ind(1) ++ "\n" else "";
    // build options
    gen_buildopts_block(all_opts, 1);
    ind(1); "\n";
    // force_load tree-sitter libs
    ind(1); "filter {}\n";
    ind(1); "linkoptions {\n";
    ind(2); "\"-Wl,-force_load,../../lambda/tree-sitter-lambda/libtree-sitter-lambda.a\",\n";
    ind(2); "\"-Wl,-force_load,../../lambda/tree-sitter/libtree-sitter.a\",\n";
    ind(1); "}\n";
    ind(1); "\n";
    // ASAN
    ind(1); "-- AddressSanitizer for test projects only\n";
    ind(1); "filter { \"configurations:Debug\", \"not platforms:Linux_x64\" }\n";
    ind(2); "buildoptions { \"-fsanitize=address\", \"-fno-omit-frame-pointer\" }\n";
    ind(2); "linkoptions { \"-fsanitize=address\" }\n";
    ind(1); "\n";
    ind(1); "filter {}\n";
    ind(1); "\n";
    "\n"
}


// ============================================================
// === Procedural Data Computation ===
// ============================================================

// array push - append item to array using ++ operator
pn arr_push(arr, item) {
    var result = arr ++ [item]
    return result
}

// prefix relative path with ../../ for premake build directory
pn make_build_path(p) {
    if (len(p) == 0) { return p }
    if (starts_with(p, "/")) { return p }
    if (starts_with(p, "-Wl,")) { return p }
    return "../../" ++ p
}

// check if item is in array
pn arr_contains(arr, item) {
    var i = 0
    while (i < len(arr)) {
        if (arr[i] == item) { return true }
        i = i + 1
    }
    return false
}

// add item to array only if not already present
pn arr_push_unique(arr, item) {
    if (item == null or item == "") { return arr }
    if (arr_contains(arr, item)) { return arr }
    return arr_push(arr, item)
}

// ============================================================
// === Build merged external_libraries map ===
// ============================================================

// Builds a flat array of {name, include, lib, link} entries
// merging global libraries + dev_libraries + platform overrides
pn build_external_libs(config, platform) {
    var result = []

    // step 1: global libraries
    var libs = config.libraries or []
    var i = 0
    while (i < len(libs)) {
        var lib = libs[i]
        result = arr_push(result, {
            name: lib.name,
            include: lib.include or "",
            lib: lib.lib or "",
            link: lib.link or "static"
        })
        i = i + 1
    }

    // step 2: dev_libraries
    var dev_libs = config.dev_libraries or []
    i = 0
    while (i < len(dev_libs)) {
        var lib = dev_libs[i]
        result = arr_push(result, {
            name: lib.name,
            include: lib.include or "",
            lib: lib.lib or "",
            link: lib.link or "static"
        })
        i = i + 1
    }

    // step 3: platform-specific overrides
    var plats = config.platforms or {}
    var plat = if (platform == "macos") plats.macos or {}
               else if (platform == "linux") plats.linux or {}
               else plats.windows or {}
    var plat_libs = plat.libraries or []
    i = 0
    while (i < len(plat_libs)) {
        var lib = plat_libs[i]
        var name = lib.name
        var link_val = lib.link or (if (platform == "macos") "dynamic" else "static")
        // check if already exists - override it
        var found = false
        var j = 0
        while (j < len(result)) {
            if (result[j].name == name) {
                found = true
                break
            }
            j = j + 1
        }
        if (not found) {
            result = arr_push(result, {
                name: name,
                include: lib.include or "",
                lib: lib.lib or "",
                link: link_val
            })
        } else {
            var new_result = []
            j = 0
            while (j < len(result)) {
                if (result[j].name == name) {
                    new_result = arr_push(new_result, {
                        name: name,
                        include: lib.include or "",
                        lib: lib.lib or "",
                        link: link_val
                    })
                } else {
                    new_result = arr_push(new_result, result[j])
                }
                j = j + 1
            }
            result = new_result
        }
        i = i + 1
    }

    // platform dev_libraries
    var plat_dev = plat.dev_libraries or []
    i = 0
    while (i < len(plat_dev)) {
        var lib = plat_dev[i]
        result = arr_push(result, {
            name: lib.name,
            include: lib.include or "",
            lib: lib.lib or "",
            link: lib.link or "static"
        })
        i = i + 1
    }

    return result
}

// find in external libs array
pn find_ext_lib(ext_libs, name) {
    var i = 0
    while (i < len(ext_libs)) {
        if (ext_libs[i].name == name) { return ext_libs[i] }
        i = i + 1
    }
    return null
}

// ============================================================
// === Build Include Lists ===
// ============================================================

// Consolidated includes: global + platform (no library includes)
pn build_consolidated_includes(config, platform) {
    var result = []
    var global_inc = config.includes or []
    var i = 0
    while (i < len(global_inc)) {
        result = arr_push_unique(result, global_inc[i])
        i = i + 1
    }
    var plats = config.platforms or {}
    var plat = if (platform == "macos") plats.macos or {}
               else if (platform == "linux") plats.linux or {}
               else plats.windows or {}
    var plat_inc = plat.includes or []
    i = 0
    while (i < len(plat_inc)) {
        result = arr_push_unique(result, plat_inc[i])
        i = i + 1
    }
    return result
}

// lambda-lib includes: consolidated + lib/mem-pool/include + dependency includes
pn build_lib_includes(config, platform, ext_libs) {
    var result = build_consolidated_includes(config, platform)
    result = arr_push_unique(result, "lib/mem-pool/include")
    // add includes for lambda-lib dependencies
    var targets = config.targets or []
    var t = find_target(targets, "lambda-lib")
    if (t != null) {
        var deps = t.libraries or []
        var i = 0
        while (i < len(deps)) {
            var lib = find_ext_lib(ext_libs, deps[i])
            if (lib != null and lib.include != null and lib.include != "") {
                result = arr_push_unique(result, lib.include)
            }
            i = i + 1
        }
    }
    return result
}

// input-full-cpp includes: consolidated + dependency includes (NO lib/mem-pool/include)
pn build_input_includes(config, platform, ext_libs) {
    var result = build_consolidated_includes(config, platform)
    // add includes for input-full dependencies
    var targets = config.targets or []
    var t = find_target(targets, "lambda-input-full")
    if (t != null) {
        var deps = t.libraries or []
        var i = 0
        while (i < len(deps)) {
            var lib = find_ext_lib(ext_libs, deps[i])
            if (lib != null and lib.include != null and lib.include != "") {
                result = arr_push_unique(result, lib.include)
            }
            i = i + 1
        }
    }
    return result
}

// full includes: consolidated + lib/mem-pool/include + ALL external lib includes
// (for main exe and tests)
pn build_full_includes(config, platform, ext_libs) {
    var result = build_consolidated_includes(config, platform)
    result = arr_push_unique(result, "lib/mem-pool/include")
    // add ALL external library includes (except dev_libraries are included by Python too)
    var i = 0
    while (i < len(ext_libs)) {
        var lib = ext_libs[i]
        if (lib.link != "none" and lib.include != null and lib.include != "") {
            result = arr_push_unique(result, lib.include)
        }
        i = i + 1
    }
    return result
}

// ============================================================
// === Build Static Library Paths ===
// ============================================================

// input-full-cpp static library paths
pn build_input_static_paths(config, ext_libs) {
    var result = []
    var targets = config.targets or []
    var t = find_target(targets, "lambda-input-full")
    if (t == null) { return result }

    var lib_names = t.libraries or []
    var i = 0
    while (i < len(lib_names)) {
        var name = lib_names[i]
        var lib = find_ext_lib(ext_libs, name)
        if (lib != null and lib.link == "static") {
            var p = lib.lib or ""
            if (p != "") {
                result = arr_push(result, make_build_path(p))
            }
        }
        i = i + 1
    }
    return result
}

// input-full-cpp dynamic link names
pn build_input_dyn_links(config, ext_libs) {
    var result = []
    var targets = config.targets or []
    var t = find_target(targets, "lambda-input-full")
    if (t == null) { return result }

    // first pass: collect dynamic external libraries
    var lib_names = t.libraries or []
    var i = 0
    while (i < len(lib_names)) {
        var name = lib_names[i]
        var lib = find_ext_lib(ext_libs, name)
        if (lib != null and lib.link == "dynamic") {
            result = arr_push(result, lib.name)
        }
        i = i + 1
    }
    // second pass: add internal project links (lambda-lib)
    i = 0
    while (i < len(lib_names)) {
        if (lib_names[i] == "lambda-lib") {
            result = arr_push(result, "lambda-lib")
        }
        i = i + 1
    }
    return result
}

// Main exe static library paths (all global + platform static libs)
pn build_exe_static_paths(config, platform, ext_libs) {
    var result = []

    // all global libraries
    var libs = config.libraries or []
    var i = 0
    while (i < len(libs)) {
        var lib = libs[i]
        if (lib.link == "static") {
            var p = lib.lib or ""
            if (p != "") {
                result = arr_push(result, make_build_path(p))
            }
        }
        i = i + 1
    }

    // platform-specific static libs
    var plats = config.platforms or {}
    var plat = if (platform == "macos") plats.macos or {}
               else if (platform == "linux") plats.linux or {}
               else plats.windows or {}
    var plat_libs = plat.libraries or []
    i = 0
    while (i < len(plat_libs)) {
        var lib = plat_libs[i]
        if (lib.link == "static") {
            var p = lib.lib or ""
            if (p != "") {
                result = arr_push(result, make_build_path(p))
            }
        }
        i = i + 1
    }

    // add base_libs duplicates that Python adds at the end for main exe
    // (mpdec, utf8proc, mir come from config.libraries but Python re-adds them)
    var base_lib_names = ["mpdec", "utf8proc", "mir"]
    i = 0
    while (i < len(base_lib_names)) {
        var name = base_lib_names[i]
        var lib = find_ext_lib(ext_libs, name)
        if (lib != null and lib.link != "dynamic" and lib.link != "none") {
            var p = lib.lib or ""
            if (p != "") {
                result = arr_push(result, make_build_path(p))
            }
        }
        i = i + 1
    }

    // nghttp2 with force_load (macOS)
    if (platform == "macos") {
        var nghttp2 = find_ext_lib(ext_libs, "nghttp2")
        if (nghttp2 != null and nghttp2.link != "dynamic" and nghttp2.link != "none") {
            var p = nghttp2.lib or ""
            if (p != "") {
                result = arr_push(result, "-Wl,-force_load," ++ make_build_path(p))
            }
        }
    }

    // curl at the end (Python re-adds it)
    var curl = find_ext_lib(ext_libs, "curl")
    if (curl != null and curl.link == "static") {
        var p = curl.lib or ""
        if (p != "") {
            result = arr_push(result, make_build_path(p))
        }
    }

    return result
}

// ============================================================
// === Input-full source file ordering ===
// ============================================================

// Reorder source files: C++ first, then C (matching Python behavior)
pn reorder_input_files(source_files) {
    var cpp_files = []
    var c_files = []
    var i = 0
    while (i < len(source_files)) {
        var f = source_files[i]
        if (ends_with(f, ".cpp")) {
            cpp_files = arr_push(cpp_files, f)
        } else if (ends_with(f, ".c")) {
            c_files = arr_push(c_files, f)
        } else {
            cpp_files = arr_push(cpp_files, f)
        }
        i = i + 1
    }
    // combine: cpp first, then c
    return cpp_files ++ c_files
}

// ============================================================
// === Test data computation ===
// ============================================================

pn build_test_sources(test_entry) {
    var result = []
    var source = test_entry.source or ""
    if (source != "") {
        var src_path = if (starts_with(source, "test/")) source else "test/" ++ source
        result = arr_push(result, src_path)
    }
    var add_srcs = test_entry.additional_sources or []
    var i = 0
    while (i < len(add_srcs)) {
        result = arr_push(result, add_srcs[i])
        i = i + 1
    }
    return result
}

pn build_test_link_names(test_entry) {
    var result = []
    var deps = test_entry.dependencies or []
    var i = 0
    while (i < len(deps)) {
        var d = deps[i]
        if (d == "lambda-input-full") {
            result = arr_push(result, "lambda-input-full-cpp")
            result = arr_push(result, "lambda-lib")
        } else {
            result = arr_push(result, d)
        }
        i = i + 1
    }
    return result
}

pn build_test_lib_paths(test_entry, ext_libs) {
    var result = []
    var test_libs = test_entry.libraries or []
    var i = 0
    while (i < len(test_libs)) {
        var name = test_libs[i]
        var lib = find_ext_lib(ext_libs, name)
        if (lib != null and lib.link == "static") {
            var p = lib.lib or ""
            if (p != "") {
                result = arr_push(result, make_build_path(p))
            }
        }
        i = i + 1
    }
    return result
}

pn has_dependency(test_entry, dep_name) {
    var deps = test_entry.dependencies or []
    var i = 0
    while (i < len(deps)) {
        if (deps[i] == dep_name) { return true }
        i = i + 1
    }
    return false
}

// split special_flags string into array of flags
pn build_extra_flags(flags_str) {
    if (flags_str == null or flags_str == "") { return [] }
    return split(flags_str, " ")
}

// check if test source file exists
pn test_source_exists(test_entry) {
    var source = test_entry.source or ""
    if (source == "") { return false }
    var path = if (starts_with(source, "test/")) source else "test/" ++ source
    return exists(path)
}


// ============================================================
// === Source File Enumeration ===
// ============================================================

// Enumerate .c and .cpp files in a single directory
// Returns files in glob order: .c files first, then .cpp files
pn enumerate_dir(dir_path) {
    var entries^err = input(dir_path, "dir")
    if (err) { return [] }
    var c_files = []
    var cpp_files = []
    var i = 0
    while (i < len(entries)) {
        let e = entries[i]
        let ext = e.extension or ""
        let name = e.name or ""
        if (ext == "c") {
            c_files = arr_push(c_files, dir_path ++ "/" ++ name)
        } else if (ext == "cpp") {
            cpp_files = arr_push(cpp_files, dir_path ++ "/" ++ name)
        }
        i = i + 1
    }
    // combine: c first, then cpp (matching Python glob order)
    return c_files ++ cpp_files
}

// Enumerate all source files from config source_dirs, applying exclusions
pn enumerate_sources(config, platform) {
    var source_dirs = config.source_dirs or []
    var excludes = config.exclude_source_files or []

    // add platform-specific exclusions
    var plats = config.platforms or {}
    var plat = if (platform == "macos") plats.macos or {}
               else if (platform == "linux") plats.linux or {}
               else plats.windows or {}
    var plat_excludes = plat.exclude_source_files or []
    excludes = excludes ++ plat_excludes

    // start with explicit source_files from config
    var all_files = config.source_files or []

    // enumerate each source directory
    var i = 0
    while (i < len(source_dirs)) {
        var dir_files = enumerate_dir(source_dirs[i])
        all_files = all_files ++ dir_files
        i = i + 1
    }

    // filter out excluded files
    var result = []
    i = 0
    while (i < len(all_files)) {
        if (not arr_contains(excludes, all_files[i])) {
            result = arr_push(result, all_files[i])
        }
        i = i + 1
    }

    return result
}

// ============================================================
// === Main Entry Point ===
// ============================================================

pn main() {
    print("Lambda Premake5 Generator v2")

    var config^err = input("build_lambda_config.json", "json")
    if (err != null) {
        print("Error: Failed to load config")
        return 1
    }

    var platform = detect_platform()
    print("Platform: " ++ platform)

    // Build merged external libraries
    print("Building external library map...")
    var ext_libs = build_external_libs(config, platform)
    print("  ext_libs: " ++ string(len(ext_libs)) ++ " entries")

    // Compute include lists
    print("Computing includes...")
    var lib_includes = build_lib_includes(config, platform, ext_libs)
    print("  lib_includes: " ++ string(len(lib_includes)))

    var input_includes = build_input_includes(config, platform, ext_libs)
    print("  input_includes: " ++ string(len(input_includes)))

    var full_includes = build_full_includes(config, platform, ext_libs)
    print("  full_includes: " ++ string(len(full_includes)))

    // Compute static paths
    print("Computing library paths...")
    var input_static_paths = build_input_static_paths(config, ext_libs)
    print("  input_static_paths: " ++ string(len(input_static_paths)))

    var input_dyn_links = build_input_dyn_links(config, ext_libs)
    print("  input_dyn_links: " ++ string(input_dyn_links))

    // Enumerate source files for main exe (using input(dir, "dir"))
    print("Enumerating source files...")
    var exe_files = enumerate_sources(config, platform)
    print("  exe_files: " ++ string(len(exe_files)))

    var exe_static_paths = build_exe_static_paths(config, platform, ext_libs)
    print("  exe_static_paths: " ++ string(len(exe_static_paths)))

    // Build output section by section
    print("Generating output...")

    // Header + workspace + configs
    var out = gen_header(platform)
    out = out ++ gen_workspace(config)
    out = out ++ gen_debug_config()
    if (platform == "macos") {
        out = out ++ gen_release_config_macos()
    } else {
        out = out ++ gen_release_config_linux()
    }
    out = out ++ gen_platform_globals()
    print("  header/workspace/configs OK")

    // lambda-lib
    var targets = config.targets or []
    var t_lib = find_target(targets, "lambda-lib")
    if (t_lib != null) {
        out = out ++ gen_lambda_lib(t_lib, lib_includes)
    }
    print("  lambda-lib OK")

    // lambda-input-full-cpp
    var t_input = find_target(targets, "lambda-input-full")
    if (t_input != null) {
        // reorder source files: C++ first, then C
        var reordered = reorder_input_files(t_input.source_files or [])
        // create a copy of the target with reordered files
        out = out ++ gen_input_full({
            source_files: reordered,
            source_patterns: t_input.source_patterns or [],
            exclude_patterns: t_input.exclude_patterns or [],
            defines: t_input.defines or [],
            link: t_input.link or "static"
        }, input_includes, input_static_paths, input_dyn_links, platform)
    }
    print("  lambda-input-full-cpp OK")

    // lambda-input-full wrapper
    out = out ++ gen_input_wrapper()
    print("  wrapper OK")

    // Main executable
    var exe_name = strip_exe(config.output or "lambda.exe")
    out = out ++ gen_lambda_exe(exe_name, exe_files, full_includes, exe_static_paths, platform)
    print("  main exe OK")

    // Test projects
    var test_cfg = config.test or {}
    var suites = test_cfg.test_suites or []
    var suite_idx = 0
    var test_count = 0
    var skip_count = 0
    while (suite_idx < len(suites)) {
        var suite = suites[suite_idx]
        var tests = suite.tests or []
        var special_flags = suite.special_flags or ""
        var test_idx = 0
        while (test_idx < len(tests)) {
            var t = tests[test_idx]
            var bin = t.binary or ""
            var proj_name = if (bin != "") strip_exe(bin) else "test_unknown"

            // skip tests whose source files don't exist
            if (not test_source_exists(t)) {
                skip_count = skip_count + 1
                test_idx = test_idx + 1
                continue
            }

            var sources = build_test_sources(t)
            var link_names = build_test_link_names(t)
            var lib_paths = build_test_lib_paths(t, ext_libs)
            var is_input = has_dependency(t, "lambda-input-full")
            var defs = t.defines or []
            // get special_flags from test entry (or suite level)
            var test_flags = t.special_flags or special_flags
            var extra = build_extra_flags(test_flags)
            // build combined buildoptions
            var all_opts = ["-pedantic", "-fdiagnostics-color=auto", "-fno-omit-frame-pointer"] ++ extra

            if (is_input) {
                out = out ++ gen_test_input_full(proj_name, sources, full_includes, link_names, lib_paths, defs, all_opts, platform)
            } else {
                out = out ++ gen_test_simple(proj_name, sources, full_includes, link_names, lib_paths, defs, all_opts)
            }

            test_count = test_count + 1
            test_idx = test_idx + 1
        }
        suite_idx = suite_idx + 1
    }
    print("  " ++ string(test_count) ++ " test projects OK (" ++ string(skip_count) ++ " skipped)")

    // Write output
    var outpath = if (platform == "macos") "temp/premake5_v2.mac.lua"
                  else if (platform == "linux") "temp/premake5_v2.linux.lua"
                  else "temp/premake5_v2.windows.lua"

    // trim trailing blank line
    if (len(out) > 1) {
        var last = slice(out, len(out) - 1, len(out))
        if (last == "\n") {
            out = slice(out, 0, len(out) - 1)
        }
    }

    out |> outpath

    print("Output: " ++ outpath)
    print("Size: " ++ string(len(out)) ++ " chars")
    print("Done!")

    return 0
}
