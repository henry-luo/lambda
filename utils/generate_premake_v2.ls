// generate_premake_v2.ls - Lambda Script Premake5 Generator
// Usage: ./lambda.exe run utils/generate_premake_v2.ls

let STAR = "*"

// Workaround for array ++ bug: use for comprehension to merge
fn arr_merge(a, b) {
    (let n = len(b),
     if (n == 0) a else [for (x in a) x, for (y in b) y])
}

fn detect_platform() {
    (let p = sys.os.platform,
     if (p == "darwin") "macos"
     else if (p == "linux") "linux"
     else "windows")
}

fn q(s: string) { "\"" ++ s ++ "\"" }

fn ind(n: int) {
    if (n <= 0) ""
    else if (n == 1) "    "
    else if (n == 2) "        "
    else "            "
}

fn strip_exe(name: string) {
    (let n = len(name),
     let has_exe = ends_with(name, ".exe"),
     if (n > 4 and has_exe) slice(name, 0, n - 4)
     else name)
}

fn join_items(items, sep: string) {
    if (len(items) == 0) ""
    else str_join(items, sep)
}

fn gen_header(platform: string) {
    "-- Generated by utils/generate_premake_v2.ls for " ++ platform ++ "\n" ++
    "-- Lambda Build System - Premake5 Configuration\n\n"
}

fn gen_workspace(c, platform: string) {
    (let ws = c.workspace_name or "Lambda",
     let out = c.output or "lambda.exe",
     let start = strip_exe(out),
     let comp = if (platform == "windows") "gcc" else "clang",
     "workspace " ++ q(ws) ++ "\n" ++
     ind(1) ++ "configurations { \"Debug\", \"Release\" }\n" ++
     ind(1) ++ "platforms { \"native\" }\n" ++
     ind(1) ++ "location \"build/premake\"\n" ++
     ind(1) ++ "startproject " ++ q(start) ++ "\n" ++
     ind(1) ++ "toolset " ++ q(comp) ++ "\n" ++
     ind(1) ++ "\n" ++
     ind(1) ++ "cppdialect \"C++17\"\n" ++
     ind(1) ++ "cdialect \"C99\"\n" ++
     ind(1) ++ "warnings \"Extra\"\n\n")
}

fn gen_debug_config() {
    ind(1) ++ "filter \"configurations:Debug\"\n" ++
    ind(2) ++ "defines { \"DEBUG\" }\n" ++
    ind(2) ++ "symbols \"On\"\n" ++
    ind(2) ++ "optimize \"Off\"\n\n"
}

fn gen_release_config(platform: string) {
    (let dead = if (platform == "macos") "-Wl,-dead_strip" else "-Wl,--gc-sections",
     ind(1) ++ "filter \"configurations:Release\"\n" ++
     ind(2) ++ "defines { \"NDEBUG\" }\n" ++
     ind(2) ++ "symbols \"Off\"\n" ++
     ind(2) ++ "optimize \"On\"\n" ++
     ind(2) ++ "buildoptions { \"-flto=thin\", \"-ffunction-sections\", \"-fdata-sections\" }\n" ++
     ind(2) ++ "linkoptions { \"-flto=thin\", " ++ q(dead) ++ " }\n\n" ++
     ind(1) ++ "filter {}\n\n")
}

fn gen_project_header(name: string, kind: string, lang: string, tdir: string) {
    "project " ++ q(name) ++ "\n" ++
    ind(1) ++ "kind " ++ q(kind) ++ "\n" ++
    ind(1) ++ "language " ++ q(lang) ++ "\n" ++
    ind(1) ++ "targetdir " ++ q(tdir) ++ "\n" ++
    ind(1) ++ "objdir \"build/obj/%{prj.name}\"\n\n"
}

fn format_file(f: string) { ind(2) ++ q(f) ++ "," }

fn gen_files_block(files) {
    (let n = len(files),
     if (n == 0) ""
     else (let items = [for (f in files) format_file(f)],
           ind(1) ++ "files {\n" ++ join_items(items, "\n") ++ "\n" ++ ind(1) ++ "}\n"))
}

fn gen_source_patterns_block(patterns) {
    (let n = len(patterns),
     if (n == 0) ""
     else (let blocks = [for (p in patterns) ind(1) ++ "files {\n" ++ ind(2) ++ q(p) ++ ",\n" ++ ind(1) ++ "}\n" ++ ind(1) ++ "\n"],
           str_join(blocks, "")))
}

fn gen_remove_files_block(patterns) {
    (let n = len(patterns),
     if (n == 0) ""
     else (let items = [for (p in patterns) ind(2) ++ q(p) ++ ","],
           ind(1) ++ "removefiles {\n" ++ join_items(items, "\n") ++ "\n" ++ ind(1) ++ "}\n" ++ ind(1) ++ "\n"))
}

fn gen_includes_block(includes) {
    (let n = len(includes),
     if (n == 0) ""
     else (let items = [for (inc in includes) ind(2) ++ q(inc) ++ ","],
           ind(1) ++ "includedirs {\n" ++ join_items(items, "\n") ++ "\n" ++ ind(1) ++ "}\n\n"))
}

fn gen_libdirs_block(platform: string) {
    if (platform == "macos")
        ind(1) ++ "libdirs {\n" ++
        ind(2) ++ "\"/opt/homebrew/lib\",\n" ++
        ind(2) ++ "\"/usr/local/lib\",\n" ++
        ind(1) ++ "}\n\n"
    else if (platform == "linux")
        ind(1) ++ "libdirs {\n" ++
        ind(2) ++ "\"/usr/local/lib\",\n" ++
        ind(2) ++ "\"/usr/lib\",\n" ++
        ind(1) ++ "}\n\n"
    else ""
}

fn gen_links_block(libs) {
    (let valid_libs = [for (lib in libs where lib != null and lib != "") lib],
     let n = len(valid_libs),
     if (n == 0) ""
     else (let items = [for (lib in valid_libs) ind(2) ++ q(lib) ++ ","],
           ind(1) ++ "links {\n" ++ join_items(items, "\n") ++ "\n" ++ ind(1) ++ "}\n\n"))
}

fn make_lib_path(lib) {
    (let p = lib.lib,
     let is_abs = starts_with(p, "/"),
     if (p == null) null
     else if (is_abs) p
     else "../../" ++ p)
}

fn gen_linkopts_block(libs, platform: string) {
    (let static_libs = [for (lib in libs where lib.link == "static" and lib.lib != null) lib],
     let n = len(static_libs),
     if (n == 0) ""
     else (let paths = [for (lib in static_libs) make_lib_path(lib)],
           let valid = [for (p in paths where p != null) p],
           let items = [for (p in valid) ind(2) ++ q(p) ++ ","],
           ind(1) ++ "linkoptions {\n" ++ join_items(items, "\n") ++ "\n" ++ ind(1) ++ "}\n\n"))
}

fn gen_buildopts_block(opts) {
    (let n = len(opts),
     if (n == 0) ""
     else (let items = [for (opt in opts) q(opt)],
           ind(1) ++ "buildoptions { " ++ join_items(items, ", ") ++ " }\n\n"))
}

fn gen_defines_block(defs) {
    (let n = len(defs),
     if (n == 0) ""
     else (let items = [for (d in defs) q(d)],
           ind(1) ++ "defines { " ++ join_items(items, ", ") ++ " }\n\n"))
}

fn get_base_includes(c, platform: string) {
    (let base = c.includes or [],
     let is_macos = platform == "macos",
     let is_linux = platform == "linux",
     let extra = if (is_macos)
         ["/opt/homebrew/include", "/opt/homebrew/opt/freetype/include/freetype2",
          "/opt/homebrew/include/libpng16", "/usr/local/include", "lib/mem-pool/include"]
     else if (is_linux)
         ["/usr/include", "/usr/include/freetype2", "/usr/local/include", "lib/mem-pool/include"]
     else ["lib/mem-pool/include"],
     arr_merge(base, extra))
}

fn find_target(targets, name: string) {
    (let found = [for (t in targets where t.name == name) t],
     if (len(found) > 0) found[0] else null)
}

fn gen_lambda_lib(c, platform: string) {
    (let targets = c.targets or [],
     let t = find_target(targets, "lambda-lib"),
     if (t == null) ""
     else (let sources = t.sources or [],
           let libs = t.libraries or [],
           let defs = t.defines or [],
           let includes = get_base_includes(c, platform),
           gen_project_header("lambda-lib", "StaticLib", "C", "build/lib") ++
           gen_files_block(sources) ++
           gen_includes_block(includes) ++
           gen_libdirs_block(platform) ++
           gen_links_block(libs) ++
           gen_buildopts_block(["-pedantic", "-fdiagnostics-color=auto", "-fno-omit-frame-pointer"]) ++
           gen_defines_block(defs)))
}

fn gen_lambda_input(c, platform: string) {
    (let targets = c.targets or [],
     let t = find_target(targets, "lambda-input-full"),
     if (t == null) ""
     else (let sources = t.source_files or [],
           let patterns = t.source_patterns or [],
           let excludes = t.exclude_patterns or [],
           let includes = get_base_includes(c, platform),
           gen_project_header("lambda-input-full-cpp", "StaticLib", "C++", "build/lib") ++
           gen_files_block(sources) ++
           gen_source_patterns_block(patterns) ++
           gen_remove_files_block(excludes) ++
           gen_includes_block(includes) ++
           gen_libdirs_block(platform) ++
           gen_buildopts_block(["-std=c++17", "-fno-omit-frame-pointer"])))
}

fn make_glob(dir: string, ext: string) {
    dir ++ "/" ++ STAR ++ "." ++ ext
}

fn gen_lambda_exe(c, platform: string) {
    (let out = c.output or "lambda.exe",
     let name = strip_exe(out),
     let dirs = c.source_dirs or [],
     let includes = get_base_includes(c, platform),
     let libs = c.libraries or [],
     let c_patterns = [for (d in dirs) make_glob(d, "c")],
     let cpp_patterns = [for (d in dirs) make_glob(d, "cpp")],
     let all_patterns = arr_merge(c_patterns, cpp_patterns),
     let is_macos = platform == "macos",
     let is_linux = platform == "linux",
     let sys_libs = if (is_macos)
         ["c++", "Cocoa.framework", "IOKit.framework", "CoreFoundation.framework", "OpenGL.framework"]
     else if (is_linux)
         ["stdc++", "pthread", "dl", "m"]
     else ["stdc++", "pthread"],
     gen_project_header(name, "ConsoleApp", "C++", ".") ++
     ind(1) ++ "targetname " ++ q(name) ++ "\n" ++
     ind(1) ++ "targetextension \".exe\"\n\n" ++
     gen_files_block(all_patterns) ++
     gen_includes_block(includes) ++
     gen_libdirs_block(platform) ++
     gen_links_block(sys_libs) ++
     gen_linkopts_block(libs, platform) ++
     gen_buildopts_block(["-std=c++17", "-fno-omit-frame-pointer"]))
}

fn gen_single_test(test, c, platform: string) {
    (let bin_name = test.binary or "",
     let has_bin = bin_name != "",
     let proj_name = if (has_bin) strip_exe(bin_name) else "test_unknown",
     let source = test.source or "",
     let add_srcs = test.additional_sources or [],
     let test_libs = test.libraries or [],
     let deps = test.dependencies or [],
     let includes = get_base_includes(c, platform),
     let libs = c.libraries or [],
     let has_source = source != "",
     let has_test_prefix = starts_with(source, "test/"),
     let src_path = if (has_source) (if (has_test_prefix) source else "test/" ++ source) else "",
     let has_src_path = src_path != "",
     let all_sources = if (has_src_path) arr_merge([src_path], add_srcs) else add_srcs,
     let is_macos = platform == "macos",
     let sys_libs = if (is_macos)
         ["c++", "Cocoa.framework", "IOKit.framework", "CoreFoundation.framework", "OpenGL.framework"]
     else ["stdc++", "pthread", "dl", "m"],
     let link_libs = arr_merge(arr_merge(deps, test_libs), sys_libs),
     gen_project_header(proj_name, "ConsoleApp", "C++", "test") ++
     ind(1) ++ "targetname " ++ q(proj_name) ++ "\n" ++
     ind(1) ++ "targetextension \".exe\"\n\n" ++
     gen_files_block(all_sources) ++
     gen_includes_block(includes) ++
     gen_libdirs_block(platform) ++
     gen_links_block(link_libs) ++
     gen_linkopts_block(libs, platform) ++
     gen_buildopts_block(["-std=c++17", "-fno-omit-frame-pointer"]))
}

fn gen_suite_tests(suite, c, platform: string) {
    (let tests = suite.tests or [],
     let results = [for (t in tests) gen_single_test(t, c, platform)],
     join_items(results, "\n"))
}

fn gen_all_tests(c, platform: string) {
    (let test_config = c.test or {},
     let suites = test_config.test_suites or [],
     let results = [for (suite in suites) gen_suite_tests(suite, c, platform)],
     join_items(results, "\n"))
}

fn build_premake(c, platform: string) {
    gen_header(platform) ++
    gen_workspace(c, platform) ++
    gen_debug_config() ++
    gen_release_config(platform) ++
    gen_lambda_lib(c, platform) ++
    gen_lambda_input(c, platform) ++
    gen_lambda_exe(c, platform) ++
    gen_all_tests(c, platform)
}

pn main() {
    print("Lambda Premake5 Generator v2")
    
    var config = input("build_lambda_config.json", "json")
    if (config == null) {
        print("Error: Failed to load config")
        return 1
    }
    
    var platform = detect_platform()
    print("Platform: " ++ platform)
    
    var content = build_premake(config, platform)
    
    if (content == null) {
        print("Error: build_premake returned null")
        return 1
    }
    
    var outpath = if (platform == "macos") "temp/premake5_v2.mac.lua"
                  else if (platform == "linux") "temp/premake5_v2.linux.lua"
                  else "temp/premake5_v2.windows.lua"
    
    content |> outpath
    
    print("Output: " ++ outpath)
    print("Size: " ++ string(len(content)) ++ " chars")
    
    return 0
}
