#pragma once

#include <string>
#include <vector>
#include <map>
#include <memory>

/**
 * C++ Integration for Browser-Generated Layout Test Data
 * 
 * This header provides types and functions to load and validate
 * layout test data generated by the Puppeteer-based extractor.
 */

namespace radiant {
namespace testing {

// Test data structures matching the JSON format
struct LayoutRect {
    int x, y, width, height;
    
    bool matches(const LayoutRect& other, double tolerance = 1.0) const {
        return std::abs(x - other.x) <= tolerance &&
               std::abs(y - other.y) <= tolerance &&
               std::abs(width - other.width) <= tolerance &&
               std::abs(height - other.height) <= tolerance;
    }
};

struct SpacingValues {
    int top, right, bottom, left;
};

struct ComputedStyle {
    std::string display;
    std::string position;
    std::string flex_direction;
    std::string justify_content;
    std::string align_items;
    std::string flex_grow;
    std::string flex_shrink;
    std::string flex_basis;
    SpacingValues margin;
    SpacingValues padding;
    SpacingValues border;
};

struct ExpectedElement {
    std::string selector;
    LayoutRect rect;
    ComputedStyle computed_style;
};

struct LayoutTestDescriptor {
    std::string test_id;
    std::string category;
    std::string spec_reference;
    std::string description;
    std::string html;
    std::string css;
    std::map<std::string, ExpectedElement> expected_layout;
    std::vector<std::string> properties_to_test;
    std::string browser_engine;
    std::string browser_version;
    std::string extraction_date;
    double tolerance_px;
};

struct LayoutDifference {
    std::string element_selector;
    std::string property_name;
    std::string expected_value;
    std::string actual_value;
    double difference;
    bool is_critical;
};

struct LayoutTestResult {
    std::string test_id;
    bool passed;
    std::vector<LayoutDifference> differences;
    double max_difference;
    int elements_tested;
    int elements_passed;
    std::string error_message;
};

// Core functionality
class BrowserLayoutValidator {
public:
    /**
     * Load test descriptor from JSON file generated by layout_extractor.js
     */
    static std::unique_ptr<LayoutTestDescriptor> loadTestDescriptor(const std::string& json_file);

    /**
     * Load test descriptor from JSON string
     */
    static std::unique_ptr<LayoutTestDescriptor> parseTestDescriptor(const std::string& json_content);

    /**
     * Validate Radiant layout against browser-generated reference data
     */
    static LayoutTestResult validateLayout(
        const LayoutTestDescriptor& test_descriptor,
        ViewTree* radiant_view_tree
    );

    /**
     * Compare individual element layout
     */
    static std::vector<LayoutDifference> compareElement(
        const ExpectedElement& expected,
        View* actual_view,
        const std::vector<std::string>& properties_to_test,
        double tolerance
    );

    /**
     * Find view in tree by CSS selector (simplified)
     */
    static View* findViewBySelector(ViewTree* tree, const std::string& selector);

    /**
     * Extract layout rect from Radiant View
     */
    static LayoutRect extractLayoutRect(View* view);

    /**
     * Generate HTML test report
     */
    static void generateTestReport(
        const std::vector<LayoutTestResult>& results,
        const std::string& output_file
    );
};

// Integration with existing Radiant test framework
class RadiantBrowserTestSuite {
public:
    /**
     * Run all browser-reference tests in a directory
     */
    static std::vector<LayoutTestResult> runTestDirectory(
        const std::string& test_dir,
        UiContext* ui_context
    );

    /**
     * Run single browser-reference test
     */
    static LayoutTestResult runSingleTest(
        const std::string& test_file,
        UiContext* ui_context
    );

    /**
     * Generate test summary report
     */
    static void generateSummaryReport(
        const std::vector<LayoutTestResult>& results,
        const std::string& output_file
    );
};

// Utility functions
namespace utils {
    /**
     * Convert CSS selector to simplified element finder
     * Supports: .class, #id, tag, tag[index]
     */
    std::string normalizeCssSelector(const std::string& selector);

    /**
     * Compare CSS property values with tolerance for numeric values
     */
    bool compareProperty(const std::string& expected, const std::string& actual, double tolerance = 1.0);

    /**
     * Extract numeric value from CSS property (e.g., "10px" -> 10)
     */
    double extractNumericValue(const std::string& css_value);
}

} // namespace testing
} // namespace radiant
