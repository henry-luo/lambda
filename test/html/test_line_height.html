<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Line Height Test</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        .test-container {
            margin: 10px 0;
            border: 1px solid #ccc;
            padding: 10px;
            display: inline-block;
            margin-right: 20px;
            margin-bottom: 20px;
        }
        .serif {
            font-family: serif;
        }
        .sans-serif {
            font-family: sans-serif;
        }
        .monospace {
            font-family: monospace;
        }
        .size-label {
            font-size: 12px;
            color: #666;
            margin-bottom: 5px;
        }
        .results {
            margin-top: 20px;
            padding: 10px;
            background-color: #f5f5f5;
            border: 1px solid #ddd;
        }
        .results table {
            border-collapse: collapse;
            width: 100%;
        }
        .results th, .results td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }
        .results th {
            background-color: #f2f2f2;
        }
    </style>
</head>
<body>
    <h1>Line Height Test</h1>
    <p>Testing line-height for different font sizes (3px to 50px) and font families.</p>

    <div id="test-divs-container">
        <!-- Test divs will be generated here -->
    </div>

    <div class="results">
        <h2>Results (check console for detailed output)</h2>
        <table id="results-table">
            <thead>
                <tr>
                    <th>Font Size (px)</th>
                    <th>Serif SVG Height</th>
                    <th>Serif SVG Ratio</th>
                    <th>Sans-Serif SVG Height</th>
                    <th>Sans-Serif SVG Ratio</th>
                    <th>Monospace SVG Height</th>
                    <th>Monospace SVG Ratio</th>
                    <th>All Methods (Serif)</th>
                    <th>All Methods (Sans-Serif)</th>
                    <th>All Methods (Monospace)</th>
                </tr>
            </thead>
            <tbody id="results-body">
                <!-- Results will be populated here -->
            </tbody>
        </table>
    </div>

    <script>
        function createTestDiv(fontSize, fontFamily, className) {
            const container = document.createElement('div');
            container.className = 'test-container';

            const label = document.createElement('div');
            label.className = 'size-label';
            label.textContent = `${fontSize}px ${fontFamily}`;

            const testDiv = document.createElement('div');
            testDiv.className = className;
            testDiv.style.fontSize = fontSize + 'px';
            testDiv.textContent = 'Sample text for line height testing Ag';
            testDiv.id = `test-${fontSize}-${className}`;

            container.appendChild(label);
            container.appendChild(testDiv);

            return container;
        }

        function getLineHeight(element) {
            const computedStyle = window.getComputedStyle(element);
            const lineHeight = computedStyle.lineHeight;
            const fontSize = parseFloat(computedStyle.fontSize);

            // If line-height is 'normal', use a more accurate measurement
            if (lineHeight === 'normal') {
                // Create a temporary element with the same font properties
                const temp = document.createElement('div');
                temp.style.position = 'absolute';
                temp.style.visibility = 'hidden';
                temp.style.fontSize = computedStyle.fontSize;
                temp.style.fontFamily = computedStyle.fontFamily;
                temp.style.fontWeight = computedStyle.fontWeight;
                temp.style.fontStyle = computedStyle.fontStyle;
                temp.style.lineHeight = 'normal';
                temp.style.padding = '0';
                temp.style.margin = '0';
                temp.style.border = 'none';
                temp.innerHTML = 'Mg'; // Use characters with ascenders and descenders

                document.body.appendChild(temp);
                const measuredHeight = temp.offsetHeight;
                document.body.removeChild(temp);

                return measuredHeight;
            } else if (lineHeight.endsWith('px')) {
                return parseFloat(lineHeight);
            } else if (!isNaN(parseFloat(lineHeight))) {
                // If it's a unitless number, multiply by font size
                return parseFloat(lineHeight) * fontSize;
            } else {
                // Fallback to computed style measurement
                const temp = document.createElement('div');
                temp.style.position = 'absolute';
                temp.style.visibility = 'hidden';
                temp.style.fontSize = computedStyle.fontSize;
                temp.style.fontFamily = computedStyle.fontFamily;
                temp.style.fontWeight = computedStyle.fontWeight;
                temp.style.fontStyle = computedStyle.fontStyle;
                temp.style.lineHeight = lineHeight;
                temp.style.padding = '0';
                temp.style.margin = '0';
                temp.style.border = 'none';
                temp.innerHTML = 'Mg';

                document.body.appendChild(temp);
                const measuredHeight = temp.offsetHeight;
                document.body.removeChild(temp);

                return measuredHeight;
            }
        }

        function measureLineHeightPrecise(fontSize, fontFamily) {
            // Method 1: Use getBoundingClientRect for sub-pixel precision
            const temp = document.createElement('div');
            temp.style.position = 'absolute';
            temp.style.visibility = 'hidden';
            temp.style.fontSize = fontSize + 'px';
            temp.style.fontFamily = fontFamily;
            temp.style.lineHeight = 'normal';
            temp.style.padding = '0';
            temp.style.margin = '0';
            temp.style.border = 'none';
            temp.style.whiteSpace = 'nowrap';
            temp.innerHTML = 'Mg'; // Use characters with ascenders and descenders

            document.body.appendChild(temp);

            // Force layout calculation
            temp.offsetHeight;

            // Use getBoundingClientRect for sub-pixel precision
            const rect = temp.getBoundingClientRect();
            const preciseHeight = rect.height;

            // Also try different measurement methods for comparison
            const offsetHeight = temp.offsetHeight;
            const clientHeight = temp.clientHeight;
            const scrollHeight = temp.scrollHeight;

            document.body.removeChild(temp);

            // Debug: log the raw measurements
            if (fontSize === 10) { // Only log for one size to avoid spam
                console.log(`Debug ${fontSize}px ${fontFamily}:`);
                console.log(`  getBoundingClientRect.height: ${rect.height}`);
                console.log(`  offsetHeight: ${offsetHeight}`);
                console.log(`  clientHeight: ${clientHeight}`);
                console.log(`  scrollHeight: ${scrollHeight}`);
                console.log(`  devicePixelRatio: ${window.devicePixelRatio}`);
            }

            return preciseHeight;
        }

        function measureWithSVG(fontSize, fontFamily) {
            // Method 3: Try SVG text measurement
            const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
            svg.style.position = 'absolute';
            svg.style.visibility = 'hidden';
            svg.style.width = '1000px';
            svg.style.height = '1000px';

            const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            text.textContent = 'Mg';
            text.style.fontSize = fontSize + 'px';
            text.style.fontFamily = fontFamily;
            text.setAttribute('x', '0');
            text.setAttribute('y', fontSize); // baseline

            svg.appendChild(text);
            document.body.appendChild(svg);

            const bbox = text.getBBox();
            document.body.removeChild(svg);

            return bbox.height;
        }

        function measureWithRange(fontSize, fontFamily) {
            // Method 4: Use Range API for text measurement
            const temp = document.createElement('div');
            temp.style.position = 'absolute';
            temp.style.visibility = 'hidden';
            temp.style.fontSize = fontSize + 'px';
            temp.style.fontFamily = fontFamily;
            temp.style.lineHeight = 'normal';
            temp.style.padding = '0';
            temp.style.margin = '0';
            temp.style.border = 'none';
            temp.style.whiteSpace = 'nowrap';
            temp.textContent = 'Mg';

            document.body.appendChild(temp);

            const range = document.createRange();
            range.selectNodeContents(temp);
            const rect = range.getBoundingClientRect();

            document.body.removeChild(temp);

            return rect.height;
        }

        function measureLineHeightCanvas(fontSize, fontFamily) {
            // Method 2: Use Canvas TextMetrics for font metrics
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            ctx.font = `${fontSize}px ${fontFamily}`;
            const metrics = ctx.measureText('Mg');

            // Calculate line height from font metrics
            const actualBoundingBoxAscent = metrics.actualBoundingBoxAscent || 0;
            const actualBoundingBoxDescent = metrics.actualBoundingBoxDescent || 0;
            const fontBoundingBoxAscent = metrics.fontBoundingBoxAscent || 0;
            const fontBoundingBoxDescent = metrics.fontBoundingBoxDescent || 0;

            // Try to get the most accurate measurement
            let lineHeight;
            if (fontBoundingBoxAscent && fontBoundingBoxDescent) {
                lineHeight = fontBoundingBoxAscent + fontBoundingBoxDescent;
            } else if (actualBoundingBoxAscent && actualBoundingBoxDescent) {
                lineHeight = actualBoundingBoxAscent + actualBoundingBoxDescent;
            } else {
                // Fallback to a typical ratio
                lineHeight = fontSize * 1.2;
            }

            return {
                lineHeight: lineHeight,
                ascent: actualBoundingBoxAscent || fontBoundingBoxAscent,
                descent: actualBoundingBoxDescent || fontBoundingBoxDescent,
                fontAscent: fontBoundingBoxAscent,
                fontDescent: fontBoundingBoxDescent
            };
        }

        function measureLineHeightDirectly(fontSize, fontFamily) {
            // Method 5: Combined approach with multiple measurements
            const rectHeight = measureLineHeightPrecise(fontSize, fontFamily);
            const canvasMetrics = measureLineHeightCanvas(fontSize, fontFamily);
            const svgHeight = measureWithSVG(fontSize, fontFamily);
            const rangeHeight = measureWithRange(fontSize, fontFamily);

            return {
                rectHeight: rectHeight,
                canvasHeight: canvasMetrics.lineHeight,
                svgHeight: svgHeight,
                rangeHeight: rangeHeight,
                canvasMetrics: canvasMetrics
            };
        }        function runTests() {
            const container = document.getElementById('test-divs-container');
            const resultsBody = document.getElementById('results-body');
            const fontFamilies = [
                { name: 'serif', className: 'serif', cssFamily: 'serif' },
                { name: 'sans-serif', className: 'sans-serif', cssFamily: 'sans-serif' },
                { name: 'monospace', className: 'monospace', cssFamily: 'monospace' }
            ];

            console.log('=== Line Height Test Results (SVG Sub-pixel Precision) ===');
            console.log('Font Size | Serif SVG Ratio | Sans-Serif SVG Ratio | Monospace SVG Ratio');
            console.log('------------------------------------------------------------------------');

            const results = {};

            // Generate test sizes from 3px to 50px
            for (let size = 3; size <= 50; size++) {
                results[size] = {};

                // Measure line height for each font family synchronously
                fontFamilies.forEach(font => {
                    // Create test div for display
                    const testContainer = createTestDiv(size, font.name, font.className);
                    container.appendChild(testContainer);

                    // Measure line height with multiple methods
                    const measurements = measureLineHeightDirectly(size, font.cssFamily);
                    results[size][font.className] = measurements;
                });

                // After measuring all fonts for this size, calculate SVG ratios and log
                if (Object.keys(results[size]).length === 3) {
                    const serifSvgRatio = (results[size].serif.svgHeight / size).toFixed(6);
                    const sansSerifSvgRatio = (results[size]['sans-serif'].svgHeight / size).toFixed(6);
                    const monospaceSvgRatio = (results[size].monospace.svgHeight / size).toFixed(6);

                    console.log(`${size}px | ${serifSvgRatio} | ${sansSerifSvgRatio} | ${monospaceSvgRatio}`);

                    // Add row to results table
                    const row = document.createElement('tr');
                    row.innerHTML = `
                        <td>${size}</td>
                        <td>${results[size].serif.svgHeight.toFixed(6)}</td>
                        <td>${serifSvgRatio}</td>
                        <td>${results[size]['sans-serif'].svgHeight.toFixed(6)}</td>
                        <td>${sansSerifSvgRatio}</td>
                        <td>${results[size].monospace.svgHeight.toFixed(6)}</td>
                        <td>${monospaceSvgRatio}</td>
                        <td>R:${results[size].serif.rectHeight.toFixed(1)} C:${results[size].serif.canvasHeight.toFixed(1)} S:${results[size].serif.svgHeight.toFixed(2)} A:${results[size].serif.rangeHeight.toFixed(1)}</td>
                        <td>R:${results[size]['sans-serif'].rectHeight.toFixed(1)} C:${results[size]['sans-serif'].canvasHeight.toFixed(1)} S:${results[size]['sans-serif'].svgHeight.toFixed(2)} A:${results[size]['sans-serif'].rangeHeight.toFixed(1)}</td>
                        <td>R:${results[size].monospace.rectHeight.toFixed(1)} C:${results[size].monospace.canvasHeight.toFixed(1)} S:${results[size].monospace.svgHeight.toFixed(2)} A:${results[size].monospace.rangeHeight.toFixed(1)}</td>
                    `;
                    resultsBody.appendChild(row);
                }
            }

            // Log summary after all measurements
            console.log('\n=== Summary (SVG Sub-pixel Analysis) ===');
            console.log('SVG measurements provide sub-pixel precision for line-height analysis.');
            console.log('Check the table below for detailed ratios and comparison with other methods.');

            // Analyze serif font anomalies using SVG measurements
            console.log('\n=== Serif Font Analysis (SVG Measurements) ===');
            const serifAnomalies = [];
            for (let size = 4; size <= 50; size++) {
                const currentRatio = results[size].serif.svgHeight / size;
                const prevRatio = results[size - 1].serif.svgHeight / (size - 1);
                const ratioJump = currentRatio - prevRatio;

                if (ratioJump > 0.02) { // Lowered threshold for sub-pixel analysis
                    serifAnomalies.push({
                        size: size,
                        lineHeight: results[size].serif.svgHeight,
                        ratio: currentRatio,
                        jump: ratioJump
                    });
                    console.log(`SVG Anomaly at ${size}px: height=${results[size].serif.svgHeight.toFixed(6)}px, ratio=${currentRatio.toFixed(6)}, jump=+${ratioJump.toFixed(6)}`);
                }
            }

            console.log(`\nFound ${serifAnomalies.length} serif anomalies in SVG measurements at sizes: ${serifAnomalies.map(a => a.size).join(', ')}`);

            // Pattern analysis
            const anomalySizes = serifAnomalies.map(a => a.size);
            const modulo4 = anomalySizes.filter(size => size % 4 === 0);
            const modulo8 = anomalySizes.filter(size => size % 8 === 0);

            console.log(`Sizes divisible by 4: ${modulo4.join(', ')} (${modulo4.length}/${anomalySizes.length})`);
            console.log(`Sizes divisible by 8: ${modulo8.join(', ')} (${modulo8.length}/${anomalySizes.length})`);

            // Calculate some statistics
            const sizes = Object.keys(results).map(Number).sort((a, b) => a - b);
            console.log('\n=== Font Family Statistics ===');

            fontFamilies.forEach(font => {
                // Calculate ratios for both rect and canvas measurements
                const rectRatios = sizes.map(size => {
                    const rectHeight = results[size][font.className].rectHeight;
                    return rectHeight / size;
                }).filter(ratio => !isNaN(ratio));

                const canvasRatios = sizes.map(size => {
                    const canvasHeight = results[size][font.className].canvasHeight;
                    return canvasHeight / size;
                }).filter(ratio => !isNaN(ratio));

                if (rectRatios.length > 0) {
                    const avgRectRatio = rectRatios.reduce((a, b) => a + b, 0) / rectRatios.length;
                    const minRectRatio = Math.min(...rectRatios);
                    const maxRectRatio = Math.max(...rectRatios);
                    const rectStdDev = Math.sqrt(rectRatios.reduce((sum, ratio) => sum + Math.pow(ratio - avgRectRatio, 2), 0) / rectRatios.length);

                    console.log(`${font.name} (Rect measurements):`);
                    console.log(`  Average ratio: ${avgRectRatio.toFixed(4)}`);
                    console.log(`  Min ratio: ${minRectRatio.toFixed(4)}`);
                    console.log(`  Max ratio: ${maxRectRatio.toFixed(4)}`);
                    console.log(`  Standard deviation: ${rectStdDev.toFixed(4)}`);
                    console.log(`  Variation range: ${(maxRectRatio - minRectRatio).toFixed(4)}`);
                }

                if (canvasRatios.length > 0) {
                    const avgCanvasRatio = canvasRatios.reduce((a, b) => a + b, 0) / canvasRatios.length;
                    const minCanvasRatio = Math.min(...canvasRatios);
                    const maxCanvasRatio = Math.max(...canvasRatios);
                    const canvasStdDev = Math.sqrt(canvasRatios.reduce((sum, ratio) => sum + Math.pow(ratio - avgCanvasRatio, 2), 0) / canvasRatios.length);

                    console.log(`${font.name} (Canvas measurements):`);
                    console.log(`  Average ratio: ${avgCanvasRatio.toFixed(4)}`);
                    console.log(`  Min ratio: ${minCanvasRatio.toFixed(4)}`);
                    console.log(`  Max ratio: ${maxCanvasRatio.toFixed(4)}`);
                    console.log(`  Standard deviation: ${canvasStdDev.toFixed(4)}`);
                    console.log(`  Variation range: ${(maxCanvasRatio - minCanvasRatio).toFixed(4)}`);
                }
                console.log(''); // Empty line for readability
            });
        }

        // Run tests when page loads
        window.addEventListener('load', () => {
            runTests();
        });
    </script>
</body>
</html>
