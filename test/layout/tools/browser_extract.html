<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Browser Layout Extractor</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background: #f5f5f5;
        }
        .controls {
            background: white;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .test-frame {
            width: 100%;
            height: 400px;
            border: 2px solid #333;
            background: white;
        }
        .output {
            background: #f8f8f8;
            padding: 15px;
            border-radius: 4px;
            margin-top: 20px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 10px;
        }
        button:hover {
            background: #0056b3;
        }
        select {
            padding: 8px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
    </style>
</head>
<body>
    <div class="controls">
        <h2>Layout Extractor for Flex Tests</h2>
        <p>Select a test file and extract its layout data:</p>
        
        <select id="testSelect">
            <option value="">Select a test file...</option>
            <option value="../data/basic/flex_001_basic_layout.html">Basic Layout</option>
            <option value="../data/basic/flex_002_wrap.html">Wrap</option>
            <option value="../data/basic/flex_003_align_items.html">Align Items</option>
            <option value="../data/basic/flex_004_column_direction.html">Column Direction</option>
            <option value="../data/basic/flex_005_flex_grow.html">Flex Grow</option>
            <option value="../data/basic/flex_006_justify_content.html">Justify Content</option>
            <option value="../data/basic/flex_007_row_reverse.html">Row Reverse</option>
            <option value="../data/basic/flex_008_flex_basis.html">Flex Basis</option>
            <option value="../data/basic/flex_009_auto_margins.html">Auto Margins</option>
            <option value="../data/basic/flex_010_wrap_reverse.html">Wrap Reverse</option>
        </select>
        
        <button onclick="loadTest()">Load Test</button>
        <button onclick="extractLayout()">Extract Layout</button>
        <button onclick="downloadJSON()">Download JSON</button>
    </div>
    
    <iframe id="testFrame" class="test-frame" src="about:blank"></iframe>
    
    <div class="output" id="output">Layout data will appear here...</div>

    <script>
        let currentLayoutData = null;
        let currentTestName = '';

        function loadTest() {
            const select = document.getElementById('testSelect');
            const frame = document.getElementById('testFrame');
            
            if (select.value) {
                frame.src = select.value;
                currentTestName = select.options[select.selectedIndex].text.toLowerCase().replace(/\s+/g, '_');
                document.getElementById('output').textContent = 'Test loaded. Click "Extract Layout" to analyze.';
            }
        }

        function extractLayout() {
            const frame = document.getElementById('testFrame');
            const output = document.getElementById('output');
            
            if (!frame.contentWindow || !frame.contentDocument) {
                output.textContent = 'Error: No test loaded or iframe not accessible.';
                return;
            }

            try {
                const doc = frame.contentDocument;
                const win = frame.contentWindow;
                
                // Extract layout data
                const layoutData = extractCompleteLayout(doc, win);
                
                // Create reference object
                const reference = {
                    test_file: currentTestName + '.html',
                    extraction_date: new Date().toISOString(),
                    browser_info: {
                        userAgent: navigator.userAgent,
                        viewport: {
                            width: win.innerWidth,
                            height: win.innerHeight
                        }
                    },
                    layout_data: layoutData
                };
                
                currentLayoutData = reference;
                output.textContent = JSON.stringify(reference, null, 2);
                
            } catch (error) {
                output.textContent = 'Error extracting layout: ' + error.message;
                console.error(error);
            }
        }

        function extractCompleteLayout(doc, win) {
            const extractElementData = (element, path = '') => {
                const rect = element.getBoundingClientRect();
                const computed = win.getComputedStyle(element);
                
                // Generate unique selector path
                const selector = generateSelector(element, path);
                
                return {
                    selector,
                    tag: element.tagName.toLowerCase(),
                    id: element.id || null,
                    classes: element.className ? element.className.split(' ').filter(c => c) : [],
                    
                    // Layout properties
                    layout: {
                        x: Math.round(rect.left * 100) / 100,
                        y: Math.round(rect.top * 100) / 100,
                        width: Math.round(rect.width * 100) / 100,
                        height: Math.round(rect.height * 100) / 100,
                        
                        // Content box dimensions
                        contentWidth: element.clientWidth,
                        contentHeight: element.clientHeight,
                        
                        // Scroll dimensions
                        scrollWidth: element.scrollWidth,
                        scrollHeight: element.scrollHeight
                    },
                    
                    // Computed CSS properties
                    computed: {
                        display: computed.display,
                        position: computed.position,
                        
                        // Box model
                        marginTop: parseFloat(computed.marginTop) || 0,
                        marginRight: parseFloat(computed.marginRight) || 0,
                        marginBottom: parseFloat(computed.marginBottom) || 0,
                        marginLeft: parseFloat(computed.marginLeft) || 0,
                        
                        paddingTop: parseFloat(computed.paddingTop) || 0,
                        paddingRight: parseFloat(computed.paddingRight) || 0,
                        paddingBottom: parseFloat(computed.paddingBottom) || 0,
                        paddingLeft: parseFloat(computed.paddingLeft) || 0,
                        
                        borderTopWidth: parseFloat(computed.borderTopWidth) || 0,
                        borderRightWidth: parseFloat(computed.borderRightWidth) || 0,
                        borderBottomWidth: parseFloat(computed.borderBottomWidth) || 0,
                        borderLeftWidth: parseFloat(computed.borderLeftWidth) || 0,
                        
                        // Flexbox properties
                        flexDirection: computed.flexDirection,
                        flexWrap: computed.flexWrap,
                        justifyContent: computed.justifyContent,
                        alignItems: computed.alignItems,
                        alignContent: computed.alignContent,
                        flexGrow: parseFloat(computed.flexGrow) || 0,
                        flexShrink: parseFloat(computed.flexShrink) || 1,
                        flexBasis: computed.flexBasis,
                        alignSelf: computed.alignSelf,
                        order: parseInt(computed.order) || 0,
                        gap: computed.gap,
                        
                        // Typography
                        fontSize: parseFloat(computed.fontSize) || 16,
                        lineHeight: computed.lineHeight,
                        fontFamily: computed.fontFamily,
                        fontWeight: computed.fontWeight,
                        textAlign: computed.textAlign,
                        verticalAlign: computed.verticalAlign
                    },
                    
                    // Text content information
                    textContent: element.textContent?.trim() || null,
                    hasTextNodes: Array.from(element.childNodes).some(n => n.nodeType === 3 && n.textContent.trim()),
                    
                    // Hierarchy information
                    childCount: element.children.length,
                    depth: (path.match(/>/g) || []).length
                };
            };
            
            // Helper to generate CSS selector
            const generateSelector = (element, basePath) => {
                if (element.id) return `#${element.id}`;
                
                let selector = element.tagName.toLowerCase();
                if (element.className) {
                    selector += '.' + element.className.split(' ').filter(c => c).join('.');
                }
                
                // Add index if there are siblings with same tag
                const parent = element.parentElement;
                if (parent) {
                    const siblings = Array.from(parent.children).filter(s => s.tagName === element.tagName);
                    if (siblings.length > 1) {
                        const index = siblings.indexOf(element);
                        selector += `:nth-of-type(${index + 1})`;
                    }
                }
                
                return basePath ? `${basePath} > ${selector}` : selector;
            };
            
            // Extract data for all elements
            const allElements = doc.querySelectorAll('*');
            const layoutData = {};
            
            allElements.forEach((element, index) => {
                const data = extractElementData(element);
                layoutData[data.selector] = data;
            });
            
            // Add viewport information
            layoutData['__viewport__'] = {
                width: win.innerWidth,
                height: win.innerHeight,
                devicePixelRatio: win.devicePixelRatio
            };
            
            // Add test metadata if available
            const metadataElement = doc.getElementById('test-metadata');
            if (metadataElement) {
                try {
                    layoutData['__metadata__'] = JSON.parse(metadataElement.textContent);
                } catch (e) {
                    layoutData['__metadata__'] = { error: 'Failed to parse metadata' };
                }
            }
            
            return layoutData;
        }

        function downloadJSON() {
            if (!currentLayoutData) {
                alert('No layout data to download. Extract layout first.');
                return;
            }
            
            const blob = new Blob([JSON.stringify(currentLayoutData, null, 2)], {
                type: 'application/json'
            });
            
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `${currentTestName}_reference.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
    </script>
</body>
</html>
