// test_latex_html_compare_gtest.cpp - Compare Lambda's TeX pipeline output against hybrid HTML references
//
// This test suite validates Lambda's LaTeX-to-HTML pipeline by comparing
// its output against hybrid HTML reference files generated by generate_latex_refs.js.
//
// All tests use the same normalization and comparison logic.
// Tests are split into:
//   - Baseline: Must-pass tests (regressions break the build)
//   - Extended: Work-in-progress tests (track progress on new features)
//
// To regenerate reference files:
//   node utils/generate_latex_refs.js --clean --force
//
// To run tests:
//   ./test/test_latex_html_compare_gtest.exe --gtest_filter="Baseline*"   # Must-pass
//   ./test/test_latex_html_compare_gtest.exe --gtest_filter="Extended*"   # WIP

#include <gtest/gtest.h>
#include <string>
#include <vector>
#include <set>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <regex>
#include <algorithm>
#include <cctype>

extern "C" {
    #include "../lib/strbuf.h"
    #include "../lib/log.h"
    #include "../lib/arena.h"
    #include "../lib/mempool.h"
}

#include "../lambda/lambda-data.hpp"
#include "../lambda/tex/tex_document_model.hpp"

namespace fs = std::filesystem;

// ============================================================================
// Baseline Fixtures - All tests that must pass
// Format: relative path from test/latex/fixtures/ without .tex extension
// ============================================================================

static const std::set<std::string> BASELINE_FIXTURES = {
    // latexjs/basic_test - all passing
    "latexjs/basic_test/01_simple_text_test",
    "latexjs/basic_test/02_bold_text_test",
    
    // latexjs/formatting - partial (some refs incomplete)
    "latexjs/formatting/01_basic_text_formatting",
    "latexjs/formatting/02_emphasis_command",
    "latexjs/formatting/03_nested_formatting",
    // "latexjs/formatting/04_underline_and_strikethrough", // latex.js doesn't support \sout
    // "latexjs/formatting/05_font_size_commands", // latex.js wraps spaces in font size spans
    "latexjs/formatting/06_text_alignment",
    
    // latexjs/symbols - all passing
    "latexjs/symbols/01_tex_char",
    "latexjs/symbols/02_tex_and",
    "latexjs/symbols/03_latex_symbol",
    "latexjs/symbols/04_predefined_symbols",
    
    // latexjs/text - all passing
    "latexjs/text/01_simple_text_in_paragraphs",
    "latexjs/text/02_paragraphs_and_newlines",
    "latexjs/text/03_paragraphs_and_indentation",
    "latexjs/text/04_utf_8_text_punctuation_tex_symbols",
    "latexjs/text/05_special_characters",
    "latexjs/text/06_dashes_dots_no_math",
    "latexjs/text/07_ligatures_and_ligature_prevention",
    "latexjs/text/08_verbatim_text",
    "latexjs/text/09_tex_and_latex_logos",
    "latexjs/text/10_alignment",
    
    // latexjs/environments - most passing
    "latexjs/environments/01_nested_horizontal_environments",
    "latexjs/environments/02_itemize_environment",
    "latexjs/environments/03_empty_and_consecutive_itemize_environmen",
    "latexjs/environments/04_nested_itemize_environments",
    "latexjs/environments/05_nested_itemize_environments_ii",
    "latexjs/environments/06_single_itemize_environment_custom_labels",
    "latexjs/environments/07_enumerate_environment",
    "latexjs/environments/08_description_environment",
    "latexjs/environments/09_quote_quotation_verse",
    // "latexjs/environments/10_font_environments", // latex.js wraps spaces in font size spans
    "latexjs/environments/11_alignment",
    "latexjs/environments/12_alignment_of_lists",
    "latexjs/environments/13_abstract_and_fonts",
    "latexjs/environments/14_comment_environment",
    
    // latexjs/whitespace - most passing
    "latexjs/whitespace/01_whitespaces_are_compressed_comments_are_",
    "latexjs/whitespace/02_how_to_force_two_paragraphs",
    "latexjs/whitespace/03_standard_double_newline_paragraph_separa",
    "latexjs/whitespace/04_and_newline_do_not_add_spaces_they_unski",
    "latexjs/whitespace/05_mbox_restricted_horizontal_mode_and_line",
    "latexjs/whitespace/06_unskip_breaks_out_of_groups_ignorespaces",
    "latexjs/whitespace/07_a_space_is_added_after_macros_that_take_",
    "latexjs/whitespace/08_space_hack_to_prevent_multiple_spaces",
    "latexjs/whitespace/09_more_than_two_newlines_including_spaces_",
    "latexjs/whitespace/10_comments_are_disregarded_and_won_t_add_a",
    "latexjs/whitespace/11_comments_are_disregarded_and_won_t_preve",
    "latexjs/whitespace/12_comments_can_remove_a_linebreak_i_e_spac",
    "latexjs/whitespace/13_one_space_inside_as_well_as_after_a_grou",
    "latexjs/whitespace/14_macros_without_arguments_ignore_spaces_a",
    "latexjs/whitespace/15_force_a_space_after_a_macro_with",
    "latexjs/whitespace/16_force_a_space_after_a_macro_with",
    "latexjs/whitespace/17_followed_by_tab_or_linebreak_is_also_a_s",
    "latexjs/whitespace/18_escaped_newlines_in_an_empty_document_or",
    "latexjs/whitespace/19_escaped_newlines_at_the_start_of_a_parag",
    "latexjs/whitespace/20_escaped_newlines_after_an_environment",
    "latexjs/whitespace/21_spaces_before_and_after_horizontal_envir",
    
    // latexjs/fonts - partial
    "latexjs/fonts/01_bfseries_declaration",
    "latexjs/fonts/02_em_and_emph",
    "latexjs/fonts/03_emph_command_and_nesting",
    "latexjs/fonts/05_fonts_reach_across_paragraphs_if_no_grou",
    "latexjs/fonts/06_monospaced_fonts_do_not_use_ligatures",
    
    // latexjs/groups - partial
    "latexjs/groups/01_groups_need_to_be_balanced",
    "latexjs/groups/02_brackets_do_not_need_to_be_balanced_they",
    
    // latexjs/macros - partial
    "latexjs/macros/01_custom_macros_without_arguments",
    "latexjs/macros/02_custom_macros_with_a_mandatory_argument",
    "latexjs/macros/03_custom_macros_with_an_optional_argument",
    
    // latexjs/label-ref - all passing
    "latexjs/label-ref/01_empty_currentlabel",
    "latexjs/label-ref/02_forward_and_back_referencing_a_label",
    "latexjs/label-ref/03_forward_referencing_a_section",
    "latexjs/label-ref/04_label_a_section_inside",
    "latexjs/label-ref/05_back_referencing_a_section",
    "latexjs/label-ref/06_forward_and_back_referencing_a_section_i",
    
    // latexjs/sectioning - all passing
    "latexjs/sectioning/01_a_chapter",
    "latexjs/sectioning/02_a_chapter_and_a_section",
    "latexjs/sectioning/03_section_inside_a_macro_correct_visual_ap",
    
    // latexjs/preamble
    "latexjs/preamble/01_document_with_a_preamble",
};

// Fixtures to exclude from extended tests - TeX engine internals not applicable to HTML output
static const std::set<std::string> EXCLUDED_FIXTURES = {
    // digestion/ - TeX digestion internals
    "digestion/box",
    "digestion/chardefs",
    "digestion/def",
    "digestion/defaultunits",
    "digestion/dollar",
    "digestion/io",
    "digestion/primes",
    "digestion/rebox",
    "digestion/testctr",
    "digestion/xargs",
    
    // expansion/ - TeX expansion primitives
    "expansion/aftergroup",
    "expansion/definedness",
    "expansion/env",
    "expansion/environments",
    "expansion/etex",
    "expansion/for",
    "expansion/ifthen",
    "expansion/lettercase",
    "expansion/meaning",
    "expansion/noexpand",
    "expansion/noexpand_conditional",
    "expansion/numexpr",
    "expansion/testexpand",
    "expansion/testif",
    "expansion/toks",
};

// ============================================================================
// Utility Functions
// ============================================================================

// Check if a fixture is in the baseline set
static bool is_baseline_fixture(const std::string& fixture) {
    return BASELINE_FIXTURES.find(fixture) != BASELINE_FIXTURES.end();
}

// Check if a fixture should be excluded from extended tests
static bool is_excluded_fixture(const std::string& fixture) {
    return EXCLUDED_FIXTURES.find(fixture) != EXCLUDED_FIXTURES.end();
}

// Read entire file into string
static std::string read_file(const fs::path& path) {
    std::ifstream ifs(path);
    if (!ifs) return "";
    std::stringstream ss;
    ss << ifs.rdbuf();
    return ss.str();
}

// Normalize HTML for hybrid comparison
// This handles differences between latex.js and latexml output styles
static std::string normalize_for_hybrid(const std::string& s) {
    std::string result;
    bool in_whitespace = false;
    for (size_t i = 0; i < s.size(); i++) {
        char c = s[i];
        // Skip ZWSP (U+200B) - 3-byte UTF-8 sequence E2 80 8B
        if ((unsigned char)c == 0xE2 && i + 2 < s.size() &&
            (unsigned char)s[i+1] == 0x80 && (unsigned char)s[i+2] == 0x8B) {
            i += 2;  // skip the 3-byte sequence
            continue;
        }
        // Skip SOFT HYPHEN (U+00AD) - 2-byte UTF-8 sequence C2 AD
        // latex.js inserts these for hyphenation, Lambda doesn't
        if ((unsigned char)c == 0xC2 && i + 1 < s.size() &&
            (unsigned char)s[i+1] == 0xAD) {
            i += 1;  // skip the 2-byte sequence
            continue;
        }
        // Treat EM SPACE (U+2003) - E2 80 83 - as regular space
        if ((unsigned char)c == 0xE2 && i + 2 < s.size() &&
            (unsigned char)s[i+1] == 0x80 && (unsigned char)s[i+2] == 0x83) {
            i += 2;  // skip the rest of the 3-byte sequence
            // Treat as whitespace
            if (!in_whitespace && !result.empty()) {
                result += ' ';
                in_whitespace = true;
            }
            continue;
        }
        if (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
            if (!in_whitespace && !result.empty()) {
                result += ' ';
                in_whitespace = true;
            }
        } else {
            result += c;
            in_whitespace = false;
        }
    }
    
    // Trim trailing whitespace
    while (!result.empty() && result.back() == ' ') {
        result.pop_back();
    }
    
    // Remove whitespace between tags
    std::string no_tag_space;
    for (size_t i = 0; i < result.size(); i++) {
        if (result[i] == ' ' && i > 0 && i + 1 < result.size() &&
            result[i - 1] == '>' && result[i + 1] == '<') {
            continue;  // skip space between tags
        }
        no_tag_space += result[i];
    }
    
    // Strip whitespace inside paragraph tags
    std::string cleaned;
    for (size_t i = 0; i < no_tag_space.size(); i++) {
        // Skip space after <p> or <p class="...">
        if (i + 3 < no_tag_space.size() &&
            no_tag_space[i] == '<' && no_tag_space[i+1] == 'p' && no_tag_space[i+2] == '>' &&
            no_tag_space[i+3] == ' ') {
            cleaned += "<p>";
            i += 3;
            continue;
        }
        if (i + 2 < no_tag_space.size() &&
            no_tag_space[i] == '>' && no_tag_space[i+1] == ' ' && i > 0) {
            size_t tag_start = no_tag_space.rfind('<', i);
            if (tag_start != std::string::npos && i - tag_start < 50) {
                std::string tag_content = no_tag_space.substr(tag_start, i - tag_start + 1);
                if (tag_content.find("<p") == 0 || tag_content.find("<p ") == 0) {
                    cleaned += '>';
                    i += 1;
                    continue;
                }
            }
        }
        // Skip space before </p>
        if (i + 4 < no_tag_space.size() &&
            no_tag_space[i] == ' ' &&
            no_tag_space[i+1] == '<' && no_tag_space[i+2] == '/' &&
            no_tag_space[i+3] == 'p' && no_tag_space[i+4] == '>') {
            continue;
        }
        cleaned += no_tag_space[i];
    }
    
    // Remove empty hbox/mbox spans (Lambda outputs these but they're semantically empty)
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="hbox"><span></span></span>)"), "");
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="hbox llap"><span></span></span>)"), "");
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="mbox"><span></span></span>)"), "");
    
    // Normalize code tags: <code class="tt"> -> <code> for hybrid comparison
    cleaned = std::regex_replace(cleaned, std::regex(R"(<code class="tt">)"), "<code>");
    
    // Normalize extra CSS classes that don't affect semantics
    // Remove "latex-article" from article class
    cleaned = std::regex_replace(cleaned, std::regex(R"(<article class="latex-document latex-article">)"), "<article class=\"latex-document\">");
    // Remove "latex-paragraph" class from p tags
    cleaned = std::regex_replace(cleaned, std::regex(R"(<p class="latex-paragraph">)"), "<p>");
    // Remove "latex-graphics" class from graphics spans  
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="latex-graphics">)"), "<span class=\"graphics\">");
    
    // Remove whitespace after <br> tags (line breaks shouldn't affect content)
    cleaned = std::regex_replace(cleaned, std::regex(R"(<br> )"), "<br>");
    cleaned = std::regex_replace(cleaned, std::regex(R"(<br/> )"), "<br/>");
    
    // Normalize SVG: strip xmlns and version attributes (don't affect rendering)
    cleaned = std::regex_replace(cleaned, std::regex(R"( xmlns="[^"]*")"), "");
    cleaned = std::regex_replace(cleaned, std::regex(R"( version="[^"]*")"), "");
    
    // Normalize empty spans with only class attribute
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="up"></span>)"), "");
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span></span>)"), "");
    
    // Remove latex.js spacing spans that contain only ZWSP + space
    // Pattern: <span class="X">​ </span> where ​ is ZWSP (E2 80 8B)
    // These are font size scope wrappers for trailing whitespace
    cleaned = std::regex_replace(cleaned, 
        std::regex(R"(<span class="[^"]+">(\xE2\x80\x8B)? </span>)"), " ");
    
    // Normalize consecutive spaces
    cleaned = std::regex_replace(cleaned, std::regex(R"(  +)"), " ");
    
    // Normalize NBSP: convert &nbsp; entity to actual NBSP (U+00A0)
    // Both forms should be treated as equivalent
    cleaned = std::regex_replace(cleaned, std::regex(R"(&nbsp;)"), "\xC2\xA0");
    
    // Strip LaTeXML footer - starts with <footer> or </div><footer>
    std::regex footer_regex(R"(<footer>[\s\S]*?</footer>)");
    cleaned = std::regex_replace(cleaned, footer_regex, "");
    
    // Strip orphan closing divs that LaTeXML adds after sections and articles
    cleaned = std::regex_replace(cleaned, std::regex(R"(</section></div>)"), "</section>");
    cleaned = std::regex_replace(cleaned, std::regex(R"(</article></div>)"), "</article>");
    
    // Strip section wrappers - LaTeXML uses <section>, Lambda might use flat structure
    // LaTeXML: <section class="section"><h2 class="section-title">...</h2>...</section>
    // Lambda:  <h2>...</h2>...
    
    // Normalize section headers: <h2 class="section-title"> -> <h2>
    cleaned = std::regex_replace(cleaned, std::regex(R"(<h2 class="section-title">)"), "<h2>");
    cleaned = std::regex_replace(cleaned, std::regex(R"(<h3 class="subsection-title">)"), "<h3>");
    cleaned = std::regex_replace(cleaned, std::regex(R"(<h4 class="subsubsection-title">)"), "<h4>");
    
    // Normalize section number spans: <span class="section-number">1 </span> -> "1 "
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="section-number">([^<]*)</span>)"), "$1");
    
    // Remove orphan </div> tags that come after content (LaTeXML artifact)
    cleaned = std::regex_replace(cleaned, std::regex(R"(</p></div>)"), "</p>");
    cleaned = std::regex_replace(cleaned, std::regex(R"(</li></div>)"), "</li>");
    cleaned = std::regex_replace(cleaned, std::regex(R"(</dd></div>)"), "</dd>");
    
    // Remove LaTeXML-specific wrapper divs
    cleaned = std::regex_replace(cleaned, std::regex(R"(<div></div>)"), "");
    
    // Strip trailing </div> at the end (LaTeXML wraps everything in an extra div)
    while (cleaned.size() > 6 && cleaned.substr(cleaned.size() - 6) == "</div>") {
        cleaned = cleaned.substr(0, cleaned.size() - 6);
    }
    
    return cleaned;
}

// Collect all .tex fixtures from the fixtures directory that have .html references
static std::vector<std::string> collect_all_fixtures() {
    std::vector<std::string> fixtures;
    fs::path fixtures_dir = "test/latex/fixtures";
    fs::path expected_dir = "test/latex/expected";
    
    if (!fs::exists(fixtures_dir)) {
        return fixtures;
    }
    
    for (const auto& entry : fs::recursive_directory_iterator(fixtures_dir)) {
        if (entry.is_regular_file() && entry.path().extension() == ".tex") {
            // Get relative path from fixtures dir, without .tex extension
            fs::path rel = fs::relative(entry.path(), fixtures_dir);
            std::string fixture = rel.string();
            // Remove .tex extension
            fixture = fixture.substr(0, fixture.length() - 4);
            
            // Check if hybrid reference exists
            fs::path ref_path = expected_dir / fixture;
            ref_path.replace_extension(".html");
            if (fs::exists(ref_path)) {
                fixtures.push_back(fixture);
            }
        }
    }
    
    std::sort(fixtures.begin(), fixtures.end());
    return fixtures;
}

// Get display name for test (converts path/to/fixture to path_to_fixture)
// GTest only allows alphanumeric and underscore in test names
static std::string get_test_display_name(const std::string& fixture) {
    std::string name = fixture;
    for (char& c : name) {
        if (c == '/' || c == '-' || c == ' ' || !std::isalnum(c)) {
            c = '_';
        }
    }
    return name;
}

// ============================================================================
// Test Base Class
// ============================================================================

class TexHtmlCompareTest : public ::testing::Test {
protected:
    static fs::path fixtures_dir;
    static fs::path expected_dir;
    
    static void SetUpTestSuite() {
        // Initialize logging from config
        log_init("log.conf");
    }
    
    static void TearDownTestSuite() {
        // Nothing to clean up - log stays open
    }
    
    // Read file contents
    static std::string read_file(const fs::path& path) {
        std::ifstream ifs(path);
        if (!ifs) return "";
        std::stringstream ss;
        ss << ifs.rdbuf();
        return ss.str();
    }
    
    // Write file contents (for debug output)
    static void write_file(const fs::path& path, const std::string& content) {
        fs::create_directories(path.parent_path());
        std::ofstream ofs(path);
        ofs << content;
    }
    
    // Core test logic - shared between Baseline and Extended
    static ::testing::AssertionResult RunCompareTest(const std::string& fixture) {
        fs::path tex_path = fixtures_dir / (fixture + ".tex");
        fs::path ref_path = expected_dir / (fixture + ".html");  // Hybrid reference
        
        // Check files exist
        if (!fs::exists(tex_path)) {
            return ::testing::AssertionFailure() << "TeX file not found: " << tex_path;
        }
        if (!fs::exists(ref_path)) {
            return ::testing::AssertionFailure() << "Reference HTML not found: " << ref_path
                << " (run: python3 utils/generate_hybrid_refs.py)";
        }
        
        // Read the TeX source
        std::string latex_content = read_file(tex_path);
        if (latex_content.empty()) {
            return ::testing::AssertionFailure() << "Failed to read TeX file: " << tex_path;
        }
        
        // Check for SKIP marker in source
        if (latex_content.find("% SKIP:") != std::string::npos) {
            // Return success but with skip message (use GTEST_SKIP in actual test)
            return ::testing::AssertionSuccess() << "SKIP";
        }
        
        // Convert using Lambda pipeline in HYBRID mode
        Pool* doc_pool = pool_create();
        Arena* doc_arena = arena_create_default(doc_pool);
        
        tex::TexDocumentModel* doc = tex::doc_model_from_string(
            latex_content.c_str(), latex_content.size(), doc_arena, nullptr);
        
        std::string lambda_html;
        if (doc && doc->root) {
            StrBuf* html_buf = strbuf_new_cap(8192);
            tex::HtmlOutputOptions opts = tex::HtmlOutputOptions::hybrid();
            opts.standalone = false;
            opts.pretty_print = false;
            
            bool success = tex::doc_model_to_html(doc, html_buf, opts);
            if (success && html_buf->length > 0) {
                lambda_html = std::string(html_buf->str, html_buf->length);
            }
            strbuf_free(html_buf);
        }
        
        arena_destroy(doc_arena);
        pool_destroy(doc_pool);
        
        // If we got no output, that's a failure
        if (lambda_html.empty()) {
            fs::path lambda_out = "test_output/hybrid/" + fixture;
            lambda_out.replace_extension(".lambda.html");
            write_file(lambda_out, "<!-- Lambda conversion failed -->\n");
            return ::testing::AssertionFailure() << "Lambda failed to convert: " << fixture;
        }
        
        // Save Lambda output for debugging
        fs::path lambda_out = "test_output/hybrid/" + fixture;
        lambda_out.replace_extension(".lambda.html");
        write_file(lambda_out, lambda_html);
        
        // Read expected HTML
        std::string expected_html = read_file(ref_path);
        
        // Normalize both for comparison
        std::string norm_lambda = normalize_for_hybrid(lambda_html);
        std::string norm_expected = normalize_for_hybrid(expected_html);
        
        // Compare
        if (norm_lambda == norm_expected) {
            return ::testing::AssertionSuccess();
        }
        
        return ::testing::AssertionFailure()
            << "\n=== Fixture: " << fixture << " ==="
            << "\n=== Expected HTML ===\n" << expected_html
            << "\n=== Actual HTML ===\n" << lambda_html;
    }
};

// Static member initialization
fs::path TexHtmlCompareTest::fixtures_dir = "test/latex/fixtures";
fs::path TexHtmlCompareTest::expected_dir = "test/latex/expected";

// ============================================================================
// Baseline Tests - Must Pass
// ============================================================================

class BaselineParamTest : public TexHtmlCompareTest,
                          public ::testing::WithParamInterface<std::string> {
};

TEST_P(BaselineParamTest, CompareHtml) {
    EXPECT_TRUE(RunCompareTest(GetParam()));
}

// Generate baseline test cases from BASELINE_FIXTURES
static std::vector<std::string> GetBaselineFixtures() {
    return std::vector<std::string>(BASELINE_FIXTURES.begin(), BASELINE_FIXTURES.end());
}

INSTANTIATE_TEST_SUITE_P(
    Baseline,
    BaselineParamTest,
    ::testing::ValuesIn(GetBaselineFixtures()),
    [](const ::testing::TestParamInfo<std::string>& info) {
        return get_test_display_name(info.param);
    }
);

// ============================================================================
// Extended Tests - Work in Progress
// ============================================================================

class ExtendedParamTest : public TexHtmlCompareTest,
                          public ::testing::WithParamInterface<std::string> {
};

TEST_P(ExtendedParamTest, CompareHtml) {
    EXPECT_TRUE(RunCompareTest(GetParam()));
}

// Generate extended test cases - all fixtures NOT in baseline and NOT excluded
static std::vector<std::string> GetExtendedFixtures() {
    std::vector<std::string> all = collect_all_fixtures();
    std::vector<std::string> extended;
    
    for (const auto& fixture : all) {
        if (!is_baseline_fixture(fixture) && !is_excluded_fixture(fixture)) {
            extended.push_back(fixture);
        }
    }
    
    return extended;
}

INSTANTIATE_TEST_SUITE_P(
    Extended,
    ExtendedParamTest,
    ::testing::ValuesIn(GetExtendedFixtures()),
    [](const ::testing::TestParamInfo<std::string>& info) {
        return get_test_display_name(info.param);
    }
);

// ============================================================================
// Main
// ============================================================================

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
