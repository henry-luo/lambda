// test_tex_dvi_comparison.cpp - Parse and inspect DVI reference files
//
// This test program:
// 1. Parses reference DVI files generated by TeX
// 2. Extracts glyph positions for reference
// 3. Provides baseline for comparison with Lambda typesetting

#include <gtest/gtest.h>
#include "lambda/tex/dvi_parser.hpp"
#include "lib/arena.h"
#include "lib/mempool.h"
#include "lib/log.h"
#include <cstdio>
#include <cstring>

using namespace tex;

// ============================================================================
// Test Fixture
// ============================================================================

class DVIComparisonTest : public ::testing::Test {
protected:
    Pool* pool;
    Arena* arena;
    static constexpr float POSITION_TOLERANCE = 2.0f;  // 2pt tolerance

    void SetUp() override {
        pool = pool_create();
        arena = arena_create_default(pool);
    }

    void TearDown() override {
        arena_destroy(arena);
        pool_destroy(pool);
    }

    // Read file contents
    char* read_file_contents(const char* path, size_t* out_len) {
        FILE* f = fopen(path, "rb");
        if (!f) return nullptr;

        fseek(f, 0, SEEK_END);
        size_t len = ftell(f);
        fseek(f, 0, SEEK_SET);

        char* buf = (char*)arena_alloc(arena, len + 1);
        fread(buf, 1, len, f);
        buf[len] = '\0';
        fclose(f);

        if (out_len) *out_len = len;
        return buf;
    }

    // Load DVI file and parse
    dvi::DVIParser* load_dvi(const char* path) {
        dvi::DVIParser* parser = (dvi::DVIParser*)arena_alloc(arena, sizeof(dvi::DVIParser));
        new (parser) dvi::DVIParser(arena);

        if (!parser->parse_file(path)) {
            log_error("Failed to parse DVI file: %s - %s", path, parser->error());
            return nullptr;
        }

        return parser;
    }

    // Extract TeX source from .tex file (skip preamble)
    const char* extract_document_content(const char* tex_source) {
        // Find \begin{document}
        const char* begin = strstr(tex_source, "\\begin{document}");
        if (!begin) return tex_source;  // No document environment

        begin += strlen("\\begin{document}");

        // Find \end{document}
        const char* end = strstr(begin, "\\end{document}");
        if (!end) return begin;

        // Copy content
        size_t len = end - begin;
        char* content = (char*)arena_alloc(arena, len + 1);
        memcpy(content, begin, len);
        content[len] = '\0';

        // Trim whitespace
        while (*content && (*content == ' ' || *content == '\n' || *content == '\r'))
            content++;

        return content;
    }
};

// ============================================================================
// DVI Parser Tests
// ============================================================================

TEST_F(DVIComparisonTest, ParseSimpleMathDVI) {
    dvi::DVIParser* parser = load_dvi("test/latex/reference/test_simple_math.dvi");

    if (parser) {
        EXPECT_GE(parser->page_count(), 1);

        const dvi::DVIPage* page = parser->page(0);
        if (page) {
            printf("Simple Math DVI: %d glyphs, %d rules\n",
                   page->glyph_count, page->rule_count);

            // Should have at least a, +, b, =, c (5 characters)
            EXPECT_GE(page->glyph_count, 5);

            // Print first few glyphs for debugging
            for (int i = 0; i < page->glyph_count && i < 10; i++) {
                const dvi::PositionedGlyph& g = page->glyphs[i];
                float x_pt = dvi::DVIParser::sp_to_pt(g.h);
                float y_pt = dvi::DVIParser::sp_to_pt(g.v);
                printf("  Glyph %d: char=%d '%c' at (%.2f, %.2f) pt\n",
                       i, g.codepoint,
                       (g.codepoint >= 32 && g.codepoint < 127) ? g.codepoint : '?',
                       x_pt, y_pt);
            }
        }
    } else {
        GTEST_SKIP() << "DVI file not found (run 'make test-tex-reference' first)";
    }
}

TEST_F(DVIComparisonTest, ParseFractionDVI) {
    dvi::DVIParser* parser = load_dvi("test/latex/reference/test_fraction.dvi");

    if (parser) {
        EXPECT_GE(parser->page_count(), 1);

        const dvi::DVIPage* page = parser->page(0);
        if (page) {
            printf("Fraction DVI: %d glyphs, %d rules\n",
                   page->glyph_count, page->rule_count);

            // Fractions should have rules (fraction bars)
            EXPECT_GE(page->rule_count, 1);
        }
    } else {
        GTEST_SKIP() << "DVI file not found";
    }
}

TEST_F(DVIComparisonTest, ParseSqrtDVI) {
    dvi::DVIParser* parser = load_dvi("test/latex/reference/test_sqrt.dvi");

    if (parser) {
        const dvi::DVIPage* page = parser->page(0);
        if (page) {
            printf("Sqrt DVI: %d glyphs, %d rules\n",
                   page->glyph_count, page->rule_count);

            // Sqrt should have rules (overline)
            EXPECT_GE(page->rule_count, 1);
        }
    } else {
        GTEST_SKIP() << "DVI file not found";
    }
}

TEST_F(DVIComparisonTest, ParseGreekDVI) {
    dvi::DVIParser* parser = load_dvi("test/latex/reference/test_greek.dvi");

    if (parser) {
        const dvi::DVIPage* page = parser->page(0);
        if (page) {
            printf("Greek DVI: %d glyphs\n", page->glyph_count);

            // Should have greek letters
            EXPECT_GE(page->glyph_count, 10);
        }
    } else {
        GTEST_SKIP() << "DVI file not found";
    }
}

TEST_F(DVIComparisonTest, ParseSumIntegralDVI) {
    dvi::DVIParser* parser = load_dvi("test/latex/reference/test_sum_integral.dvi");

    if (parser) {
        const dvi::DVIPage* page = parser->page(0);
        if (page) {
            printf("Sum/Integral DVI: %d glyphs, %d rules\n",
                   page->glyph_count, page->rule_count);
        }
    } else {
        GTEST_SKIP() << "DVI file not found";
    }
}

// ============================================================================
// DVI Dump Tests (for debugging)
// ============================================================================

TEST_F(DVIComparisonTest, DumpAllDVIFiles) {
    const char* dvi_files[] = {
        "test/latex/reference/test_simple_text.dvi",
        "test/latex/reference/test_simple_math.dvi",
        "test/latex/reference/test_fraction.dvi",
        "test/latex/reference/test_subscript_superscript.dvi",
        "test/latex/reference/test_sqrt.dvi",
        "test/latex/reference/test_greek.dvi",
        "test/latex/reference/test_sum_integral.dvi",
        "test/latex/reference/test_delimiters.dvi",
        "test/latex/reference/test_complex_formula.dvi",
        nullptr
    };

    printf("\n=== DVI File Summary ===\n\n");

    for (int i = 0; dvi_files[i]; i++) {
        dvi::DVIParser* parser = load_dvi(dvi_files[i]);
        if (parser) {
            printf("%-50s: %d pages", dvi_files[i], parser->page_count());
            if (parser->page_count() > 0) {
                const dvi::DVIPage* page = parser->page(0);
                printf(", %d glyphs, %d rules",
                       page->glyph_count, page->rule_count);
            }
            printf("\n");
        } else {
            printf("%-50s: [NOT FOUND]\n", dvi_files[i]);
        }
    }
}

// ============================================================================
// Main
// ============================================================================

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
