// test_latexml_compare_gtest.cpp - Compare Lambda's TeX pipeline output against LaTeXML references
//
// This test suite validates Lambda's LaTeX-to-HTML pipeline by comparing
// its output against HTML references generated by LaTeXML.
//
// Test categories:
// - LaTeXMLCompareTest: Parameterized tests for all fixtures
// - HTML normalization and comparison utilities
//
// To regenerate reference files:
//   ./utils/generate_latexml_refs.sh --clean
// LaTeXML references are stored as *.latexml.html in test/latexml/expected/
//
// To run specific test:
//   ./test/test_latexml_compare_gtest.exe --gtest_filter=*def*

#include <gtest/gtest.h>
#include <string>
#include <vector>
#include <filesystem>
#include <fstream>
#include <sstream>
#include <regex>
#include <algorithm>
#include <cctype>

extern "C" {
    #include "../lib/strbuf.h"
    #include "../lib/log.h"
    #include "../lib/arena.h"
    #include "../lib/mempool.h"
}

#include "../lambda/input/input.hpp"
#include "../lambda/lambda-data.hpp"
#include "../lambda/format/format.h"
#include "../lambda/tex/tex_document_model.hpp"

namespace fs = std::filesystem;

// ============================================================================
// HTML Normalization Utilities
// ============================================================================

namespace html_normalize {

// Remove all whitespace for structural comparison
std::string remove_whitespace(const std::string& html) {
    std::string result;
    result.reserve(html.size());
    bool in_tag = false;
    bool last_was_space = false;
    
    for (char c : html) {
        if (c == '<') {
            in_tag = true;
            result += c;
            last_was_space = false;
        } else if (c == '>') {
            in_tag = false;
            result += c;
            last_was_space = false;
        } else if (std::isspace(static_cast<unsigned char>(c))) {
            // Collapse whitespace outside tags
            if (!in_tag && !last_was_space) {
                result += ' ';
                last_was_space = true;
            } else if (in_tag) {
                result += ' ';
            }
        } else {
            result += c;
            last_was_space = false;
        }
    }
    return result;
}

// Remove HTML comments
std::string remove_comments(const std::string& html) {
    std::regex comment_re("<!--[\\s\\S]*?-->");
    return std::regex_replace(html, comment_re, "");
}

// Remove specific attributes that vary (ids, about, resource, etc.)
std::string remove_varying_attrs(const std::string& html) {
    std::string result = html;
    
    // Remove id attributes
    result = std::regex_replace(result, std::regex(R"(\s+id="[^"]*")"), "");
    
    // Remove xml:id attributes
    result = std::regex_replace(result, std::regex(R"(\s+xml:id="[^"]*")"), "");
    
    // Remove about/resource (RDFa) attributes
    result = std::regex_replace(result, std::regex(R"(\s+about="[^"]*")"), "");
    result = std::regex_replace(result, std::regex(R"(\s+resource="[^"]*")"), "");
    
    // Remove data-* attributes
    result = std::regex_replace(result, std::regex(R"(\s+data-[a-z-]+="[^"]*")"), "");
    
    return result;
}

// Remove DOCTYPE and XML declarations
std::string remove_declarations(const std::string& html) {
    std::string result = html;
    result = std::regex_replace(result, std::regex(R"(<!DOCTYPE[^>]*>)"), "");
    result = std::regex_replace(result, std::regex(R"(<\?xml[^>]*\?>)"), "");
    return result;
}

// Extract body content only (skip head)
std::string extract_body(const std::string& html) {
    std::regex body_re(R"(<body[^>]*>([\s\S]*)</body>)", std::regex::icase);
    std::smatch match;
    if (std::regex_search(html, match, body_re)) {
        return match[1].str();
    }
    // If no body tag, return as-is (might be a fragment)
    return html;
}

// Normalize MathML (remove presentation hints, normalize structure)
std::string normalize_mathml(const std::string& html) {
    std::string result = html;
    
    // Remove mathvariant attributes (styling)
    result = std::regex_replace(result, std::regex(R"(\s+mathvariant="[^"]*")"), "");
    
    // Remove stretchy attributes
    result = std::regex_replace(result, std::regex(R"(\s+stretchy="[^"]*")"), "");
    
    // Remove fence attributes
    result = std::regex_replace(result, std::regex(R"(\s+fence="[^"]*")"), "");
    
    // Remove form attributes
    result = std::regex_replace(result, std::regex(R"(\s+form="[^"]*")"), "");
    
    return result;
}

// Normalize class names between Lambda and LaTeXML for comparison
// This allows structural comparison without penalizing different naming conventions
std::string normalize_class_names(const std::string& html) {
    std::string result = html;
    
    // Lambda class -> LaTeXML equivalent
    // Document structure
    result = std::regex_replace(result, std::regex(R"(class="latex-document[^"]*")"), "class=\"ltx_document\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-paragraph[^"]*")"), "class=\"ltx_para\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-section[^"]*")"), "class=\"ltx_section\"");
    
    // Headings
    result = std::regex_replace(result, std::regex(R"(class="latex-heading[^"]*")"), "class=\"ltx_title\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-section-number[^"]*")"), "class=\"ltx_tag\"");
    
    // Text styling
    result = std::regex_replace(result, std::regex(R"(class="latex-emph[^"]*")"), "class=\"ltx_emph\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-textbf[^"]*")"), "class=\"ltx_text ltx_font_bold\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-textit[^"]*")"), "class=\"ltx_text ltx_font_italic\"");
    
    // Lists
    result = std::regex_replace(result, std::regex(R"(class="latex-itemize[^"]*")"), "class=\"ltx_itemize\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-enumerate[^"]*")"), "class=\"ltx_enumerate\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-item[^"]*")"), "class=\"ltx_item\"");
    
    // Math
    result = std::regex_replace(result, std::regex(R"(class="latex-math[^"]*")"), "class=\"ltx_Math\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-equation[^"]*")"), "class=\"ltx_equation\"");
    
    // Figures and tables
    result = std::regex_replace(result, std::regex(R"(class="latex-figure[^"]*")"), "class=\"ltx_figure\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-table[^"]*")"), "class=\"ltx_tabular\"");
    result = std::regex_replace(result, std::regex(R"(class="latex-caption[^"]*")"), "class=\"ltx_caption\"");
    
    // Remove remaining class attributes that don't match (cleaner comparison)
    // result = std::regex_replace(result, std::regex(R"(\s+class="[^"]*")"), "");
    
    return result;
}

// Full normalization for comparison
std::string normalize_for_comparison(const std::string& html) {
    std::string result = html;
    result = remove_declarations(result);
    result = remove_comments(result);
    result = remove_varying_attrs(result);
    result = extract_body(result);
    result = normalize_mathml(result);
    result = normalize_class_names(result);  // Normalize Lambda -> LaTeXML class names
    result = remove_whitespace(result);
    
    // Convert to lowercase for case-insensitive comparison
    std::transform(result.begin(), result.end(), result.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    
    return result;
}

// Tokenize HTML for element-by-element comparison
std::vector<std::string> tokenize_html(const std::string& html) {
    std::vector<std::string> tokens;
    std::regex token_re(R"(<[^>]+>|[^<]+)");
    
    auto begin = std::sregex_iterator(html.begin(), html.end(), token_re);
    auto end = std::sregex_iterator();
    
    for (auto i = begin; i != end; ++i) {
        std::string token = (*i).str();
        // Trim whitespace
        token.erase(0, token.find_first_not_of(" \t\n\r"));
        token.erase(token.find_last_not_of(" \t\n\r") + 1);
        if (!token.empty()) {
            tokens.push_back(token);
        }
    }
    return tokens;
}

// Calculate similarity between two HTML strings (0.0 - 1.0)
double calculate_similarity(const std::string& html1, const std::string& html2) {
    auto tokens1 = tokenize_html(normalize_for_comparison(html1));
    auto tokens2 = tokenize_html(normalize_for_comparison(html2));
    
    if (tokens1.empty() && tokens2.empty()) return 1.0;
    if (tokens1.empty() || tokens2.empty()) return 0.0;
    
    // Count matching tokens
    size_t matches = 0;
    size_t i1 = 0, i2 = 0;
    
    while (i1 < tokens1.size() && i2 < tokens2.size()) {
        if (tokens1[i1] == tokens2[i2]) {
            matches++;
            i1++;
            i2++;
        } else {
            // Try to find match ahead
            bool found = false;
            for (size_t j = i2 + 1; j < std::min(i2 + 5, tokens2.size()); j++) {
                if (tokens1[i1] == tokens2[j]) {
                    i2 = j;
                    found = true;
                    break;
                }
            }
            if (!found) {
                i1++;
            }
        }
    }
    
    return (2.0 * matches) / (tokens1.size() + tokens2.size());
}

} // namespace html_normalize

// ============================================================================
// Test Fixture
// ============================================================================

class LaTeXMLCompareTest : public ::testing::Test {
protected:
    Pool* pool;
    Arena* arena;
    
public:
    static fs::path fixtures_dir;
    static fs::path expected_dir;
    static std::vector<std::string> test_files;
    
protected:
    void SetUp() override {
        pool = pool_create();
        arena = arena_create_default(pool);
        log_init(nullptr);
    }
    
    void TearDown() override {
        arena_destroy(arena);
        pool_destroy(pool);
    }
    
    // Read file contents
    std::string read_file(const fs::path& path) {
        std::ifstream file(path);
        if (!file.is_open()) {
            return "";
        }
        std::stringstream buffer;
        buffer << file.rdbuf();
        return buffer.str();
    }
    
    // Write file contents
    void write_file(const fs::path& path, const std::string& content) {
        fs::create_directories(path.parent_path());
        std::ofstream file(path);
        file << content;
    }
    
    // Convert LaTeX to HTML using Lambda's unified pipeline (doc model based)
    std::string latex_to_html(const std::string& latex_content, const std::string& filename) {
        // Create pool and arena for document model
        Pool* doc_pool = pool_create();
        Arena* doc_arena = arena_create_default(doc_pool);
        
        // Build document model using unified pipeline
        tex::TexDocumentModel* doc = tex::doc_model_from_string(
            latex_content.c_str(), latex_content.size(), doc_arena, nullptr);
        
        if (!doc || !doc->root) {
            arena_destroy(doc_arena);
            pool_destroy(doc_pool);
            return "";
        }
        
        // Render to HTML using hybrid mode
        StrBuf* html_buf = strbuf_new_cap(8192);
        tex::HtmlOutputOptions opts = tex::HtmlOutputOptions::hybrid();
        opts.standalone = false;  // No DOCTYPE/head/body wrapper for comparison
        opts.pretty_print = false;  // Compact output for comparison
        
        bool success = tex::doc_model_to_html(doc, html_buf, opts);
        
        std::string result;
        if (success && html_buf->length > 0) {
            result = std::string(html_buf->str, html_buf->length);
        }
        
        strbuf_free(html_buf);
        arena_destroy(doc_arena);
        pool_destroy(doc_pool);
        
        return result;
    }
    
public:
    // Get list of all test files
    static std::vector<std::string> get_test_files() {
        std::vector<std::string> files;
        
        if (!fs::exists(fixtures_dir)) {
            return files;
        }
        
        for (const auto& entry : fs::recursive_directory_iterator(fixtures_dir)) {
            if (entry.is_regular_file() && entry.path().extension() == ".tex") {
                // Skip math directory
                std::string path_str = entry.path().string();
                if (path_str.find("/math/") == std::string::npos) {
                    // Get relative path from fixtures_dir
                    fs::path rel = fs::relative(entry.path(), fixtures_dir);
                    files.push_back(rel.string());
                }
            }
        }
        
        std::sort(files.begin(), files.end());
        return files;
    }
};

// Static member initialization
fs::path LaTeXMLCompareTest::fixtures_dir = "test/latexml/fixtures";
fs::path LaTeXMLCompareTest::expected_dir = "test/latexml/expected";
std::vector<std::string> LaTeXMLCompareTest::test_files;

// ============================================================================
// Parameterized Test
// ============================================================================

class LaTeXMLCompareParamTest : public LaTeXMLCompareTest,
                                 public ::testing::WithParamInterface<std::string> {
};

TEST_P(LaTeXMLCompareParamTest, CompareAgainstReference) {
    std::string rel_path = GetParam();
    
    // Build paths
    fs::path tex_path = fixtures_dir / rel_path;
    // Reference files use .latexml.html suffix
    fs::path ref_path = expected_dir / rel_path;
    ref_path.replace_extension(".latexml.html");
    
    // Check if files exist
    ASSERT_TRUE(fs::exists(tex_path)) << "Fixture not found: " << tex_path;
    
    // Check for error marker (LaTeXML failed to convert)
    fs::path error_path = ref_path;
    error_path += ".error";
    if (fs::exists(error_path)) {
        GTEST_SKIP() << "LaTeXML failed to convert this file";
    }
    
    // Read LaTeX source
    std::string latex_content = read_file(tex_path);
    ASSERT_FALSE(latex_content.empty()) << "Empty LaTeX file: " << tex_path;
    
    // Convert using Lambda pipeline
    std::string lambda_html = latex_to_html(latex_content, rel_path);
    
    // If we got no output, that's a failure
    if (lambda_html.empty()) {
        // Save the attempt for debugging
        fs::path lambda_out = "test_output/latexml/" + rel_path;
        lambda_out.replace_extension(".lambda.html");
        write_file(lambda_out, "<!-- Lambda conversion failed -->\n");
        FAIL() << "Lambda failed to convert: " << rel_path;
    }
    
    // Save Lambda output for debugging
    fs::path lambda_out = "test_output/latexml/" + rel_path;
    lambda_out.replace_extension(".lambda.html");
    write_file(lambda_out, lambda_html);
    
    // Check if reference exists
    if (!fs::exists(ref_path)) {
        // No reference yet - this is expected for new files
        // The test passes but we note it
        std::cout << "  [NO REF] " << rel_path 
                  << " - Run generate_latexml_refs.sh to create" << std::endl;
        GTEST_SKIP() << "Reference not yet generated";
    }
    
    // Read reference HTML
    std::string ref_html = read_file(ref_path);
    
    // Normalize both for comparison
    std::string norm_lambda = html_normalize::normalize_for_comparison(lambda_html);
    std::string norm_ref = html_normalize::normalize_for_comparison(ref_html);
    
    // Calculate similarity
    double similarity = html_normalize::calculate_similarity(lambda_html, ref_html);
    
    // For now, we use a similarity threshold rather than exact match
    // This allows for minor differences in formatting while catching major issues
    constexpr double SIMILARITY_THRESHOLD = 0.5;  // 50% minimum similarity
    
    if (similarity < SIMILARITY_THRESHOLD) {
        // Save diff for analysis
        fs::path diff_out = "test_output/latexml/" + rel_path;
        diff_out.replace_extension(".diff.txt");
        
        std::ostringstream diff;
        diff << "Similarity: " << (similarity * 100) << "%\n";
        diff << "Threshold: " << (SIMILARITY_THRESHOLD * 100) << "%\n\n";
        diff << "=== Lambda Output (normalized) ===\n";
        diff << norm_lambda.substr(0, 2000) << "\n...\n\n";
        diff << "=== Reference (normalized) ===\n";
        diff << norm_ref.substr(0, 2000) << "\n...\n";
        
        write_file(diff_out, diff.str());
        
        FAIL() << "HTML output differs significantly from reference.\n"
               << "Similarity: " << (similarity * 100) << "%\n"
               << "See: " << diff_out;
    }
    
    // Log success with similarity
    if (similarity < 0.9) {
        std::cout << "  [PARTIAL] " << rel_path 
                  << " (" << (int)(similarity * 100) << "% similar)" << std::endl;
    }
}

// Generate parameter values
std::vector<std::string> GetTestFiles() {
    return LaTeXMLCompareTest::get_test_files();
}

INSTANTIATE_TEST_SUITE_P(
    LaTeXMLFixtures,
    LaTeXMLCompareParamTest,
    ::testing::ValuesIn(GetTestFiles()),
    [](const ::testing::TestParamInfo<std::string>& info) {
        // Create test name from path (replace / and . with _)
        std::string name = info.param;
        std::replace(name.begin(), name.end(), '/', '_');
        std::replace(name.begin(), name.end(), '.', '_');
        std::replace(name.begin(), name.end(), '-', '_');
        return name;
    }
);

// ============================================================================
// Individual Tests for Specific Categories
// ============================================================================

TEST_F(LaTeXMLCompareTest, DigestDefTest) {
    std::string latex = R"(
\documentclass{article}
\def\foo#1{\textbf{#1}}
\begin{document}
Normal macro: \foo{test}
\end{document}
)";
    
    std::string html = latex_to_html(latex, "test_def.tex");
    EXPECT_FALSE(html.empty()) << "Failed to convert basic def test";
    
    // Check for expected content
    EXPECT_TRUE(html.find("Normal macro") != std::string::npos) 
        << "Missing expected text in output";
}

TEST_F(LaTeXMLCompareTest, StructureSectionTest) {
    std::string latex = R"(
\documentclass{article}
\begin{document}
\section{Introduction}
This is the introduction.
\subsection{Background}
Some background information.
\end{document}
)";
    
    std::string html = latex_to_html(latex, "test_section.tex");
    EXPECT_FALSE(html.empty()) << "Failed to convert section test";
    
    // Check for section headers
    EXPECT_TRUE(html.find("Introduction") != std::string::npos);
    EXPECT_TRUE(html.find("Background") != std::string::npos);
}

TEST_F(LaTeXMLCompareTest, AMSMathTest) {
    std::string latex = R"(
\documentclass{article}
\usepackage{amsmath}
\begin{document}
\begin{equation}
E = mc^2
\end{equation}
\end{document}
)";
    
    std::string html = latex_to_html(latex, "test_amsmath.tex");
    EXPECT_FALSE(html.empty()) << "Failed to convert AMS math test";
}

// ============================================================================
// Utility Test for Normalization
// ============================================================================

TEST(HtmlNormalizeTest, RemoveWhitespace) {
    std::string input = "<p>Hello   \n  World</p>";
    std::string expected = "<p>Hello World</p>";
    EXPECT_EQ(html_normalize::remove_whitespace(input), expected);
}

TEST(HtmlNormalizeTest, RemoveComments) {
    std::string input = "<p>Hello<!-- comment -->World</p>";
    std::string expected = "<p>HelloWorld</p>";
    EXPECT_EQ(html_normalize::remove_comments(input), expected);
}

TEST(HtmlNormalizeTest, ExtractBody) {
    std::string input = "<html><head><title>T</title></head><body><p>Content</p></body></html>";
    std::string expected = "<p>Content</p>";
    EXPECT_EQ(html_normalize::extract_body(input), expected);
}

TEST(HtmlNormalizeTest, Similarity) {
    std::string html1 = "<p>Hello World</p>";
    std::string html2 = "<p>Hello World</p>";
    EXPECT_DOUBLE_EQ(html_normalize::calculate_similarity(html1, html2), 1.0);
    
    std::string html3 = "<p>Goodbye World</p>";
    double sim = html_normalize::calculate_similarity(html1, html3);
    EXPECT_GT(sim, 0.5);  // Some similarity
    EXPECT_LT(sim, 1.0);  // But not identical
}

// ============================================================================
// Hybrid Mode Test Suite
// Tests Lambda's hybrid HTML output against .html reference files
// Hybrid mode uses semantic HTML5 elements without CSS class prefixes
// ============================================================================

class HybridFixturesTest : public LaTeXMLCompareTest {
public:
    static fs::path hybrid_fixtures_dir;
    static fs::path hybrid_expected_dir;
    static std::vector<std::string> hybrid_test_files;
    
    // Get list of hybrid test files (latexjs fixtures that have .html refs)
    static std::vector<std::string> get_hybrid_test_files() {
        std::vector<std::string> files;
        fs::path fixtures_dir = "test/latexml/fixtures/latexjs";
        fs::path expected_dir = "test/latexml/expected/latexjs";
        
        if (!fs::exists(fixtures_dir)) {
            return files;
        }
        
        for (const auto& entry : fs::recursive_directory_iterator(fixtures_dir)) {
            if (entry.is_regular_file() && entry.path().extension() == ".tex") {
                fs::path rel = fs::relative(entry.path(), fixtures_dir);
                // Check if hybrid reference exists
                fs::path ref_path = expected_dir / rel;
                ref_path.replace_extension(".html");
                if (fs::exists(ref_path)) {
                    files.push_back(rel.string());
                }
            }
        }
        
        std::sort(files.begin(), files.end());
        return files;
    }
};

// Static member initialization
fs::path HybridFixturesTest::hybrid_fixtures_dir = "test/latexml/fixtures/latexjs";
fs::path HybridFixturesTest::hybrid_expected_dir = "test/latexml/expected/latexjs";
std::vector<std::string> HybridFixturesTest::hybrid_test_files;

// Baseline fixtures for hybrid tests
// Format: "category/##_slug" where ## is the fixture number
static const std::set<std::string> HYBRID_BASELINE_FIXTURES = {
    // basic_test - all passing
    "basic_test/01_simple_text_test",
    "basic_test/02_bold_text_test",
    // formatting - all passing
    "formatting/01_basic_text_formatting",
    "formatting/02_emphasis_command",
    "formatting/03_nested_formatting",
    "formatting/04_underline_and_strikethrough",
    "formatting/05_font_size_commands",
    "formatting/06_text_alignment",
    // symbols - all passing
    "symbols/01_tex_char",
    "symbols/02_tex_and",
    "symbols/03_latex_symbol",
    "symbols/04_predefined_symbols",
    // text - all passing
    "text/01_simple_text_in_paragraphs",
    "text/02_paragraphs_and_newlines",
    "text/03_paragraphs_and_indentation",
    "text/04_utf_8_text_punctuation_tex_symbols",
    "text/05_special_characters",
    "text/06_dashes_dots_no_math",
    "text/07_ligatures_and_ligature_prevention",
    "text/08_verbatim_text",
    "text/09_tex_and_latex_logos",
    "text/10_alignment",
    // environments - partial
    "environments/01_nested_horizontal_environments",
    "environments/02_itemize_environment",
    "environments/03_empty_and_consecutive_itemize_environmen",
    "environments/04_nested_itemize_environments",
    "environments/05_nested_itemize_environments_ii",
    "environments/06_single_itemize_environment_custom_labels",
    "environments/07_enumerate_environment",
    "environments/08_description_environment",
    "environments/09_quote_quotation_verse",
    "environments/10_font_environments",
    "environments/11_alignment",
    "environments/12_alignment_of_lists",
    "environments/14_comment_environment",
    // whitespace - partial
    "whitespace/01_whitespaces_are_compressed_comments_are_",
    "whitespace/02_how_to_force_two_paragraphs",
    "whitespace/03_standard_double_newline_paragraph_separa",
    "whitespace/04_and_newline_do_not_add_spaces_they_unski",
    "whitespace/09_more_than_two_newlines_including_spaces_",
    "whitespace/10_comments_are_disregarded_and_won_t_add_a",
    "whitespace/11_comments_are_disregarded_and_won_t_preve",
    "whitespace/12_comments_can_remove_a_linebreak_i_e_spac",
    "whitespace/13_one_space_inside_as_well_as_after_a_grou",
    "whitespace/14_macros_without_arguments_ignore_spaces_a",
    "whitespace/15_force_a_space_after_a_macro_with",
    "whitespace/16_force_a_space_after_a_macro_with",
    "whitespace/17_followed_by_tab_or_linebreak_is_also_a_s",
    "whitespace/18_escaped_newlines_in_an_empty_document_or",
    "whitespace/19_escaped_newlines_at_the_start_of_a_parag",
    "whitespace/20_escaped_newlines_after_an_environment",
    // fonts - partial
    "fonts/01_bfseries_declaration",
    "fonts/02_em_and_emph",
    "fonts/03_emph_command_and_nesting",
    // groups - partial
    "groups/01_groups_need_to_be_balanced",
    "groups/02_brackets_do_not_need_to_be_balanced_they",
    // macros - partial
    "macros/01_custom_macros_without_arguments",
    // preamble - partial
    "preamble/01_document_with_a_preamble",
};

// Check if a fixture is in the baseline set
static bool is_hybrid_baseline(const std::string& rel_path) {
    // Remove .tex extension
    std::string path = rel_path;
    if (path.size() > 4 && path.substr(path.size() - 4) == ".tex") {
        path = path.substr(0, path.size() - 4);
    }
    return HYBRID_BASELINE_FIXTURES.count(path) > 0;
}

// Helper to normalize HTML for hybrid comparison
static std::string normalize_for_hybrid(const std::string& s) {
    std::string result;
    bool in_whitespace = false;
    for (size_t i = 0; i < s.size(); i++) {
        char c = s[i];
        // Skip ZWSP (U+200B) - 3-byte UTF-8 sequence E2 80 8B
        if ((unsigned char)c == 0xE2 && i + 2 < s.size() && 
            (unsigned char)s[i+1] == 0x80 && (unsigned char)s[i+2] == 0x8B) {
            i += 2;  // skip the 3-byte sequence
            continue;
        }
        if (c == ' ' || c == '\t' || c == '\n' || c == '\r') {
            if (!in_whitespace && !result.empty()) {
                result += ' ';
                in_whitespace = true;
            }
        } else {
            result += c;
            in_whitespace = false;
        }
    }
    
    // Trim trailing whitespace
    while (!result.empty() && result.back() == ' ') {
        result.pop_back();
    }
    
    // Remove whitespace between tags
    std::string no_tag_space;
    for (size_t i = 0; i < result.size(); i++) {
        if (result[i] == ' ' && i > 0 && i + 1 < result.size() &&
            result[i - 1] == '>' && result[i + 1] == '<') {
            continue;  // skip space between tags
        }
        no_tag_space += result[i];
    }
    
    // Strip whitespace inside paragraph tags
    std::string cleaned;
    for (size_t i = 0; i < no_tag_space.size(); i++) {
        // Skip space after <p> or <p class="...">
        if (i + 3 < no_tag_space.size() &&
            no_tag_space[i] == '<' && no_tag_space[i+1] == 'p' && no_tag_space[i+2] == '>' &&
            no_tag_space[i+3] == ' ') {
            cleaned += "<p>";
            i += 3;
            continue;
        }
        if (i + 2 < no_tag_space.size() &&
            no_tag_space[i] == '>' && no_tag_space[i+1] == ' ' && i > 0) {
            size_t tag_start = no_tag_space.rfind('<', i);
            if (tag_start != std::string::npos && i - tag_start < 50) {
                std::string tag_content = no_tag_space.substr(tag_start, i - tag_start + 1);
                if (tag_content.find("<p") == 0 || tag_content.find("<p ") == 0) {
                    cleaned += '>';
                    i += 1;
                    continue;
                }
            }
        }
        // Skip space before </p>
        if (i + 4 < no_tag_space.size() &&
            no_tag_space[i] == ' ' &&
            no_tag_space[i+1] == '<' && no_tag_space[i+2] == '/' && 
            no_tag_space[i+3] == 'p' && no_tag_space[i+4] == '>') {
            continue;
        }
        cleaned += no_tag_space[i];
    }
    
    // Remove empty hbox/mbox spans (Lambda outputs these but they're semantically empty)
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="hbox"><span></span></span>)"), "");
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="hbox llap"><span></span></span>)"), "");
    cleaned = std::regex_replace(cleaned, std::regex(R"(<span class="mbox"><span></span></span>)"), "");
    
    // Normalize code tags: <code class="tt"> -> <code> for hybrid comparison
    cleaned = std::regex_replace(cleaned, std::regex(R"(<code class="tt">)"), "<code>");
    
    return cleaned;
}

// Generate parameter values for hybrid baseline fixtures
std::vector<std::string> GetHybridBaselineFiles() {
    std::vector<std::string> all = HybridFixturesTest::get_hybrid_test_files();
    std::vector<std::string> baseline;
    for (const auto& f : all) {
        if (is_hybrid_baseline(f)) {
            baseline.push_back(f);
        }
    }
    return baseline;
}

// Generate parameter values for hybrid extended fixtures
std::vector<std::string> GetHybridExtendedFiles() {
    std::vector<std::string> all = HybridFixturesTest::get_hybrid_test_files();
    std::vector<std::string> extended;
    for (const auto& f : all) {
        if (!is_hybrid_baseline(f)) {
            extended.push_back(f);
        }
    }
    return extended;
}

// Baseline hybrid test suite - must all pass
class HybridBaselineParamTest : public HybridFixturesTest,
                                 public ::testing::WithParamInterface<std::string> {
};

TEST_P(HybridBaselineParamTest, CompareAgainstHybridRef) {
    std::string rel_path = GetParam();
    
    // Build paths
    fs::path tex_path = hybrid_fixtures_dir / rel_path;
    fs::path expected_path = hybrid_expected_dir / rel_path;
    expected_path.replace_extension(".html");  // Hybrid refs use .html
    
    // Check if files exist
    ASSERT_TRUE(fs::exists(tex_path)) << "Fixture not found: " << tex_path;
    
    // Read LaTeX source
    std::string latex_content = read_file(tex_path);
    ASSERT_FALSE(latex_content.empty()) << "Empty LaTeX file: " << tex_path;
    
    // Check for SKIP marker in source
    if (latex_content.find("% SKIP:") != std::string::npos) {
        GTEST_SKIP() << "Marked as SKIP in fixture";
    }
    
    // Convert using Lambda pipeline in HYBRID mode
    Pool* doc_pool = pool_create();
    Arena* doc_arena = arena_create_default(doc_pool);
    
    tex::TexDocumentModel* doc = tex::doc_model_from_string(
        latex_content.c_str(), latex_content.size(), doc_arena, nullptr);
    
    std::string lambda_html;
    if (doc && doc->root) {
        StrBuf* html_buf = strbuf_new_cap(8192);
        tex::HtmlOutputOptions opts = tex::HtmlOutputOptions::hybrid();
        opts.standalone = false;
        opts.pretty_print = false;
        
        bool success = tex::doc_model_to_html(doc, html_buf, opts);
        if (success && html_buf->length > 0) {
            lambda_html = std::string(html_buf->str, html_buf->length);
        }
        strbuf_free(html_buf);
    }
    
    arena_destroy(doc_arena);
    pool_destroy(doc_pool);
    
    // If we got no output, that's a failure
    if (lambda_html.empty()) {
        fs::path lambda_out = "test_output/hybrid/" + rel_path;
        lambda_out.replace_extension(".lambda.html");
        write_file(lambda_out, "<!-- Lambda conversion failed -->\n");
        FAIL() << "Lambda failed to convert: " << rel_path;
    }
    
    // Save Lambda output for debugging
    fs::path lambda_out = "test_output/hybrid/" + rel_path;
    lambda_out.replace_extension(".lambda.html");
    write_file(lambda_out, lambda_html);
    
    // Check if expected file exists
    if (!fs::exists(expected_path)) {
        GTEST_SKIP() << "Expected output not found: " << expected_path;
    }
    
    // Read expected HTML
    std::string expected_html = read_file(expected_path);
    
    // Normalize both for comparison
    std::string norm_lambda = normalize_for_hybrid(lambda_html);
    std::string norm_expected = normalize_for_hybrid(expected_html);
    
    EXPECT_EQ(norm_expected, norm_lambda)
        << "\n=== HYBRID BASELINE Fixture: " << rel_path << " ==="
        << "\n=== Expected HTML ===\n" << expected_html
        << "\n=== Actual HTML ===\n" << lambda_html;
}

// Extended hybrid test suite - work in progress
class HybridExtendedParamTest : public HybridFixturesTest,
                                 public ::testing::WithParamInterface<std::string> {
};

TEST_P(HybridExtendedParamTest, CompareAgainstHybridRef) {
    std::string rel_path = GetParam();
    
    // Build paths
    fs::path tex_path = hybrid_fixtures_dir / rel_path;
    fs::path expected_path = hybrid_expected_dir / rel_path;
    expected_path.replace_extension(".html");
    
    // Check if files exist
    ASSERT_TRUE(fs::exists(tex_path)) << "Fixture not found: " << tex_path;
    
    // Read LaTeX source
    std::string latex_content = read_file(tex_path);
    ASSERT_FALSE(latex_content.empty()) << "Empty LaTeX file: " << tex_path;
    
    // Check for SKIP marker in source
    if (latex_content.find("% SKIP:") != std::string::npos) {
        GTEST_SKIP() << "Marked as SKIP in fixture";
    }
    
    // Convert using Lambda pipeline in HYBRID mode
    Pool* doc_pool = pool_create();
    Arena* doc_arena = arena_create_default(doc_pool);
    
    tex::TexDocumentModel* doc = tex::doc_model_from_string(
        latex_content.c_str(), latex_content.size(), doc_arena, nullptr);
    
    std::string lambda_html;
    if (doc && doc->root) {
        StrBuf* html_buf = strbuf_new_cap(8192);
        tex::HtmlOutputOptions opts = tex::HtmlOutputOptions::hybrid();
        opts.standalone = false;
        opts.pretty_print = false;
        
        bool success = tex::doc_model_to_html(doc, html_buf, opts);
        if (success && html_buf->length > 0) {
            lambda_html = std::string(html_buf->str, html_buf->length);
        }
        strbuf_free(html_buf);
    }
    
    arena_destroy(doc_arena);
    pool_destroy(doc_pool);
    
    // If we got no output, that's a failure
    if (lambda_html.empty()) {
        fs::path lambda_out = "test_output/hybrid/" + rel_path;
        lambda_out.replace_extension(".lambda.html");
        write_file(lambda_out, "<!-- Lambda conversion failed -->\n");
        FAIL() << "Lambda failed to convert: " << rel_path;
    }
    
    // Save Lambda output for debugging
    fs::path lambda_out = "test_output/hybrid/" + rel_path;
    lambda_out.replace_extension(".lambda.html");
    write_file(lambda_out, lambda_html);
    
    // Check if expected file exists
    if (!fs::exists(expected_path)) {
        GTEST_SKIP() << "Expected output not found: " << expected_path;
    }
    
    // Read expected HTML
    std::string expected_html = read_file(expected_path);
    
    // Normalize both for comparison
    std::string norm_lambda = normalize_for_hybrid(lambda_html);
    std::string norm_expected = normalize_for_hybrid(expected_html);
    
    EXPECT_EQ(norm_expected, norm_lambda)
        << "\n=== HYBRID EXTENDED Fixture: " << rel_path << " ==="
        << "\n=== Expected HTML ===\n" << expected_html
        << "\n=== Actual HTML ===\n" << lambda_html;
}

INSTANTIATE_TEST_SUITE_P(
    HybridBaseline,
    HybridBaselineParamTest,
    ::testing::ValuesIn(GetHybridBaselineFiles()),
    [](const ::testing::TestParamInfo<std::string>& info) {
        std::string name = info.param;
        std::replace(name.begin(), name.end(), '/', '_');
        std::replace(name.begin(), name.end(), '.', '_');
        std::replace(name.begin(), name.end(), '-', '_');
        return name;
    }
);

INSTANTIATE_TEST_SUITE_P(
    HybridExtended,
    HybridExtendedParamTest,
    ::testing::ValuesIn(GetHybridExtendedFiles()),
    [](const ::testing::TestParamInfo<std::string>& info) {
        std::string name = info.param;
        std::replace(name.begin(), name.end(), '/', '_');
        std::replace(name.begin(), name.end(), '.', '_');
        std::replace(name.begin(), name.end(), '-', '_');
        return name;
    }
);

// ============================================================================
// Main
// ============================================================================

int main(int argc, char** argv) {
    ::testing::InitGoogleTest(&argc, argv);
    
    // Initialize test file lists
    LaTeXMLCompareTest::test_files = LaTeXMLCompareTest::get_test_files();
    LatexJsFixturesTest::latexjs_test_files = LatexJsFixturesTest::get_latexjs_test_files();
    HybridFixturesTest::hybrid_test_files = HybridFixturesTest::get_hybrid_test_files();
    
    std::cout << "LaTeXML Comparison Tests" << std::endl;
    std::cout << "========================" << std::endl;
    std::cout << "Fixtures: " << LaTeXMLCompareTest::fixtures_dir << std::endl;
    std::cout << "Expected: " << LaTeXMLCompareTest::expected_dir << std::endl;
    std::cout << "Test files: " << LaTeXMLCompareTest::test_files.size() << std::endl;
    std::cout << std::endl;
    std::cout << "LaTeX.js Fixtures" << std::endl;
    std::cout << "-----------------" << std::endl;
    std::cout << "Fixtures: " << LatexJsFixturesTest::latexjs_fixtures_dir << std::endl;
    std::cout << "Expected: " << LatexJsFixturesTest::latexjs_expected_dir << std::endl;
    std::cout << "Test files: " << LatexJsFixturesTest::latexjs_test_files.size() << std::endl;
    std::cout << std::endl;
    std::cout << "Hybrid Mode Fixtures" << std::endl;
    std::cout << "--------------------" << std::endl;
    std::cout << "Fixtures: " << HybridFixturesTest::hybrid_fixtures_dir << std::endl;
    std::cout << "Expected: " << HybridFixturesTest::hybrid_expected_dir << std::endl;
    std::cout << "Test files: " << HybridFixturesTest::hybrid_test_files.size() << std::endl;
    std::cout << std::endl;
    
    return RUN_ALL_TESTS();
}
